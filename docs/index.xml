<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on CIRCT</title><link>https://circt.llvm.org/docs/</link><description>Recent content in Code Documentation on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/DCPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/DCPasses/</guid><description>-dc-dematerialize-forks-sinks: Dematerialize fork and sink operations. This pass analyses a function-like operation and removes all fork and sink operations.
-dc-materialize-forks-sinks: Materialize fork and sink operations. This pass analyses a function-like operation and inserts fork and sink operations ensuring that all values have exactly one use.</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogeneous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>EDA Tool Workarounds</title><link>https://circt.llvm.org/docs/ToolsWorkarounds/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/ToolsWorkarounds/</guid><description>This documents various bugs found in EDA tools and their workarounds in circt. Each but will have a brief description, example code, and the mitigation added (with links to the commit when possible).
Automatic Variables Cause Latch Warnings Verilator issues a latch warning for fully-initialized, automatic variables. This precludes using locally scoped variables. https://github.com/verilator/verilator/issues/4022
Example module ALU( input clock, input [4:0] operation, input [63:0] inputs_1, inputs_0, inputs_2, input [16:0] immediate, output [63:0] output_0 ); reg [63:0] casez_tmp_1; always_comb begin automatic logic [63:0] lowHigh; casez (operation) 5&amp;#39;b00011: casez_tmp_1 = inputs_0 &amp;amp; inputs_1; 5&amp;#39;b00100: casez_tmp_1 = inputs_0 | inputs_1; 5&amp;#39;b00101: casez_tmp_1 = inputs_0 ^ inputs_1; 5&amp;#39;b01001: begin automatic logic [16:0] _aluOutput_T_22 = immediate &amp;gt;&amp;gt; {14&amp;#39;h0, inputs_2, inputs_1[0], inputs_0[0]}; casez_tmp_1 = {63&amp;#39;h0, _aluOutput_T_22[0]}; end default: casez_tmp_1 = inputs_0; endcase end endmodule Gives:</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -calyx-remove-groups-fsm: Perform FSM outlining and group removal -convert-affine-to-loopschedule: Convert Affine dialect to LoopSchedule scheduled loops -convert-comb-to-arith: Convert combinational ops and constants into arith ops -convert-fsm-to-sv: Convert FSM to HW -convert-hw-to-llhd: Convert HW to LLHD -convert-hw-to-llvm: Convert HW to LLVM -convert-hw-to-systemc: Convert HW to SystemC -convert-llhd-to-llvm: Convert LLHD to LLVM -convert-moore-to-core: Convert Moore to Core -convert-to-arcs: Outline logic between registers into state transfer arcs -export-chisel-interface: Emit a Chisel interface to a FIRRTL circuit -export-split-chisel-interface: Emit a Chisel interface to a FIRRTL circuit to a directory of files -export-split-verilog: Emit the IR to a (System)Verilog directory of files -export-verilog: Emit the IR to a (System)Verilog file -handshake-remove-block-structure: Remove block structure in Handshake IR -insert-merge-blocks: Insert explicit merge blocks -legalize-anon-enums: Prepare anonymous enumeration types for ExportVerilog -lower-arc-to-llvm: Lower state transfer arc representation to LLVM -lower-calyx-to-fsm: Lower Calyx to FSM -lower-calyx-to-hw: Lower Calyx to HW -lower-firrtl-to-hw: Lower FIRRTL to HW -lower-handshake-to-dc: Lower Handshake to DC -lower-handshake-to-hw: Lower Handshake to ESI/HW/Comb/Seq -lower-hwarith-to-hw: Lower HWArith to HW/Comb -lower-loopschedule-to-calyx: Lower LoopSchedule to Calyx -lower-pipeline-to-hw: Lower Pipeline to HW -lower-scf-to-calyx: Lower SCF/Standard to Calyx -lower-std-to-handshake: Lower Standard MLIR into Handshake IR -materialize-calyx-to-fsm: Materializes an FSM embedded inside the control of this Calyx component.</description></item><item><title>Static scheduling infrastructure</title><link>https://circt.llvm.org/docs/Scheduling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Scheduling/</guid><description>Scheduling is a common concern in hardware design, for example in high-level synthesis flows targeting an FSM+Datapath execution model (&amp;ldquo;static HLS&amp;rdquo;). This document gives an overview of, and provides rationale for, the infrastructure in the circt::scheduling namespace. At its core, it defines an extensible problem model that acts as an interface between clients (i.e. passes that have a need to schedule a graph-like IR) and reusable algorithm implementations.
This infrastructure aims to provide:</description></item><item><title>Symbol and Inner Symbol Rationale</title><link>https://circt.llvm.org/docs/RationaleSymbols/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSymbols/</guid><description>This document describes various design points of the major CIRCT dialects relating to the use of symbols and the introduction of inner symbols and related types. This follows in the spirit of other MLIR Rationale docs.
Introduction Verilog and FIRRTL have, from a software compiler perspective, an unusual number of nameable entities which can be referred to non-locally. These entities have deep nesting in the code structures. The requirements of dealing with these entities and references entails more complexity than provided by MLIR&amp;rsquo;s symbols and symbol tables.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntactically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>