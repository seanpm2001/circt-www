<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Passes - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Passes/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Passes</h1><p>This document describes the available CIRCT passes and their contracts.</p><p><nav id=TableOfContents><ul><li><a href=#conversion-passes>Conversion Passes</a><ul><li><a href=#-calyx-remove-groups-fsm-perform-fsm-outlining-and-group-removal><code>-calyx-remove-groups-fsm</code>: Perform FSM outlining and group removal</a></li><li><a href=#-convert-affine-to-loopschedule-convert-affine-dialect-to-loopschedule-scheduled-loops><code>-convert-affine-to-loopschedule</code>: Convert Affine dialect to LoopSchedule scheduled loops</a></li><li><a href=#-convert-comb-to-arith-convert-combinational-ops-and-constants-into-arith-ops><code>-convert-comb-to-arith</code>: Convert combinational ops and constants into arith ops</a></li><li><a href=#-convert-fsm-to-sv-convert-fsm-to-hw><code>-convert-fsm-to-sv</code>: Convert FSM to HW</a></li><li><a href=#-convert-hw-to-llhd-convert-hw-to-llhd><code>-convert-hw-to-llhd</code>: Convert HW to LLHD</a></li><li><a href=#-convert-hw-to-llvm-convert-hw-to-llvm><code>-convert-hw-to-llvm</code>: Convert HW to LLVM</a></li><li><a href=#-convert-hw-to-systemc-convert-hw-to-systemc><code>-convert-hw-to-systemc</code>: Convert HW to SystemC</a></li><li><a href=#-convert-llhd-to-llvm-convert-llhd-to-llvm><code>-convert-llhd-to-llvm</code>: Convert LLHD to LLVM</a></li><li><a href=#-convert-moore-to-core-convert-moore-to-core><code>-convert-moore-to-core</code>: Convert Moore to Core</a></li><li><a href=#-convert-to-arcs-outline-logic-between-registers-into-state-transfer-arcs><code>-convert-to-arcs</code>: Outline logic between registers into state transfer arcs</a></li><li><a href=#-export-chisel-interface-emit-a-chisel-interface-to-a-firrtl-circuit><code>-export-chisel-interface</code>: Emit a Chisel interface to a FIRRTL circuit</a></li><li><a href=#-export-split-chisel-interface-emit-a-chisel-interface-to-a-firrtl-circuit-to-a-directory-of-files><code>-export-split-chisel-interface</code>: Emit a Chisel interface to a FIRRTL circuit to a directory of files</a></li><li><a href=#-export-split-verilog-emit-the-ir-to-a-systemverilog-directory-of-files><code>-export-split-verilog</code>: Emit the IR to a (System)Verilog directory of files</a></li><li><a href=#-export-verilog-emit-the-ir-to-a-systemverilog-file><code>-export-verilog</code>: Emit the IR to a (System)Verilog file</a></li><li><a href=#-handshake-remove-block-structure-remove-block-structure-in-handshake-ir><code>-handshake-remove-block-structure</code>: Remove block structure in Handshake IR</a></li><li><a href=#-insert-merge-blocks-insert-explicit-merge-blocks><code>-insert-merge-blocks</code>: Insert explicit merge blocks</a></li><li><a href=#-legalize-anon-enums-prepare-anonymous-enumeration-types-for-exportverilog><code>-legalize-anon-enums</code>: Prepare anonymous enumeration types for ExportVerilog</a></li><li><a href=#-lower-arc-to-llvm-lower-state-transfer-arc-representation-to-llvm><code>-lower-arc-to-llvm</code>: Lower state transfer arc representation to LLVM</a></li><li><a href=#-lower-calyx-to-fsm-lower-calyx-to-fsm><code>-lower-calyx-to-fsm</code>: Lower Calyx to FSM</a></li><li><a href=#-lower-calyx-to-hw-lower-calyx-to-hw><code>-lower-calyx-to-hw</code>: Lower Calyx to HW</a></li><li><a href=#-lower-firrtl-to-hw-lower-firrtl-to-hw><code>-lower-firrtl-to-hw</code>: Lower FIRRTL to HW</a></li><li><a href=#-lower-handshake-to-dc-lower-handshake-to-dc><code>-lower-handshake-to-dc</code>: Lower Handshake to DC</a></li><li><a href=#-lower-handshake-to-hw-lower-handshake-to-esihwcombseq><code>-lower-handshake-to-hw</code>: Lower Handshake to ESI/HW/Comb/Seq</a></li><li><a href=#-lower-hwarith-to-hw-lower-hwarith-to-hwcomb><code>-lower-hwarith-to-hw</code>: Lower HWArith to HW/Comb</a></li><li><a href=#-lower-loopschedule-to-calyx-lower-loopschedule-to-calyx><code>-lower-loopschedule-to-calyx</code>: Lower LoopSchedule to Calyx</a></li><li><a href=#-lower-pipeline-to-hw-lower-pipeline-to-hw><code>-lower-pipeline-to-hw</code>: Lower Pipeline to HW</a></li><li><a href=#-lower-scf-to-calyx-lower-scfstandard-to-calyx><code>-lower-scf-to-calyx</code>: Lower SCF/Standard to Calyx</a></li><li><a href=#-lower-std-to-handshake-lower-standard-mlir-into-handshake-ir><code>-lower-std-to-handshake</code>: Lower Standard MLIR into Handshake IR</a></li><li><a href=#-materialize-calyx-to-fsm-materializes-an-fsm-embedded-inside-the-control-of-this-calyx-component><code>-materialize-calyx-to-fsm</code>: Materializes an FSM embedded inside the control of this Calyx component.</a></li><li><a href=#-maximize-ssa-convert-every-function-in-the-module-into-maximal-ssa-form><code>-maximize-ssa</code>: Convert every function in the module into maximal SSA form</a></li><li><a href=#-prepare-for-emission-prepare-ir-for-exportverilog><code>-prepare-for-emission</code>: Prepare IR for ExportVerilog</a></li><li><a href=#-test-apply-lowering-options-apply-lowering-options><code>-test-apply-lowering-options</code>: Apply lowering options</a></li></ul></li><li><a href=#arc-dialect-passes>Arc Dialect Passes</a><ul><li><a href=#-arc-add-taps-add-taps-to-ports-and-wires-such-that-they-remain-observable><code>-arc-add-taps</code>: Add taps to ports and wires such that they remain observable</a></li><li><a href=#-arc-allocate-state-allocate-and-layout-the-global-simulation-state><code>-arc-allocate-state</code>: Allocate and layout the global simulation state</a></li><li><a href=#-arc-canonicalizer-simulation-centric-canonicalizations><code>-arc-canonicalizer</code>: Simulation centric canonicalizations</a></li><li><a href=#-arc-dedup-deduplicate-identical-arc-definitions><code>-arc-dedup</code>: Deduplicate identical arc definitions</a></li><li><a href=#-arc-group-resets-and-enables-group-reset-and-enable-conditions-of-lowered-states><code>-arc-group-resets-and-enables</code>: Group reset and enable conditions of lowered states</a></li><li><a href=#-arc-infer-memories-convert-firrtl_memory-instances-to-dedicated-memory-ops><code>-arc-infer-memories</code>: Convert <code>FIRRTL_Memory</code> instances to dedicated memory ops</a></li><li><a href=#-arc-infer-state-properties-add-resets-and-enables-explicitly-to-the-state-operations><code>-arc-infer-state-properties</code>: Add resets and enables explicitly to the state operations</a></li><li><a href=#-arc-inline-inline-very-small-arcs><code>-arc-inline</code>: Inline very small arcs</a></li><li><a href=#-arc-inline-modules-eagerly-inline-private-modules><code>-arc-inline-modules</code>: Eagerly inline private modules</a></li><li><a href=#-arc-isolate-clocks-group-clocked-operations-into-clock-domains><code>-arc-isolate-clocks</code>: Group clocked operations into clock domains</a></li><li><a href=#-arc-latency-retiming-push-latencies-through-the-design><code>-arc-latency-retiming</code>: Push latencies through the design</a></li><li><a href=#-arc-legalize-state-update-insert-temporaries-such-that-state-reads-dont-see-writes><code>-arc-legalize-state-update</code>: Insert temporaries such that state reads don&rsquo;t see writes</a></li><li><a href=#-arc-lower-clocks-to-funcs-lower-clock-trees-into-functions><code>-arc-lower-clocks-to-funcs</code>: Lower clock trees into functions</a></li><li><a href=#-arc-lower-lut-lowers-arclut-into-a-comb-and-hw-only-representation><code>-arc-lower-lut</code>: Lowers arc.lut into a comb and hw only representation.</a></li><li><a href=#-arc-lower-state-split-state-into-read-and-write-ops-grouped-by-clock-tree><code>-arc-lower-state</code>: Split state into read and write ops grouped by clock tree</a></li><li><a href=#-arc-make-tables-transform-appropriate-arc-logic-into-lookup-tables><code>-arc-make-tables</code>: Transform appropriate arc logic into lookup tables</a></li><li><a href=#-arc-mux-to-control-flow-convert-muxes-with-large-independent-fan-ins-to-if-statements><code>-arc-mux-to-control-flow</code>: Convert muxes with large independent fan-ins to if-statements</a></li><li><a href=#-arc-print-state-info-print-the-state-storage-layout-in-json-format><code>-arc-print-state-info</code>: Print the state storage layout in JSON format</a></li><li><a href=#-arc-simplify-variadic-ops-convert-variadic-ops-into-distributed-binary-ops><code>-arc-simplify-variadic-ops</code>: Convert variadic ops into distributed binary ops</a></li><li><a href=#-arc-split-loops-split-arcs-to-break-zero-latency-loops><code>-arc-split-loops</code>: Split arcs to break zero latency loops</a></li><li><a href=#-arc-strip-sv-remove-sv-wire-reg-and-assigns><code>-arc-strip-sv</code>: Remove SV wire, reg, and assigns</a></li></ul></li><li><a href=#calyx-dialect-passes>Calyx Dialect Passes</a><ul><li><a href=#-calyx-clk-insertion-inserts-assignments-from-component-clock-to-sub-component-clock><code>-calyx-clk-insertion</code>: Inserts assignments from component clock to sub-component clock.</a></li><li><a href=#-calyx-compile-control-generates-latency-insensitive-finite-state-machines-to-realize-control><code>-calyx-compile-control</code>: Generates latency-insensitive finite state machines to realize control.</a></li><li><a href=#-calyx-gicm-lift-group-invariant-operations-to-wire-scope><code>-calyx-gicm</code>: Lift group-invariant operations to wire-scope.</a></li><li><a href=#-calyx-go-insertion-insert-go-signals-into-the-guards-of-a-groups-non-hole-assignments><code>-calyx-go-insertion</code>: Insert go signals into the guards of a group&rsquo;s non-hole assignments</a></li><li><a href=#-calyx-remove-comb-groups-removes-combinational-groups-from-a-calyx-component><code>-calyx-remove-comb-groups</code>: Removes combinational groups from a Calyx component.</a></li></ul></li><li><a href=#example>Example</a><ul><li><a href=#-calyx-remove-groups-inlines-the-groups-in-a-calyx-component><code>-calyx-remove-groups</code>: Inlines the groups in a Calyx component.</a></li><li><a href=#-calyx-reset-insertion-connect-component-reset-to-sub-component-reset-for-applicable-components><code>-calyx-reset-insertion</code>: Connect component reset to sub-component reset for applicable components.</a></li></ul></li><li><a href=#esi-dialect-passes>ESI Dialect Passes</a><ul><li><a href=#-esi-clean-metadata-clean-up-esi-service-metadata><code>-esi-clean-metadata</code>: Clean up ESI service metadata</a></li><li><a href=#-esi-connect-services-connect-up-esi-service-requests-to-service-providers><code>-esi-connect-services</code>: Connect up ESI service requests to service providers</a></li><li><a href=#-esi-emit-collateral-emit-all-the-neccessary-collateral><code>-esi-emit-collateral</code>: Emit all the neccessary collateral</a></li><li><a href=#-esi-emit-cpp-api-add-c-cosimulation-api-to-the-module><code>-esi-emit-cpp-api</code>: Add C++ cosimulation API to the module</a></li><li><a href=#-lower-esi-ports-lower-esi-input-andor-output-ports><code>-lower-esi-ports</code>: Lower ESI input and/or output ports.</a></li><li><a href=#-lower-esi-to-hw-lower-esi-to-hw-where-possible-and-sv-elsewhere><code>-lower-esi-to-hw</code>: Lower ESI to HW where possible and SV elsewhere.</a></li><li><a href=#-lower-esi-to-physical-lower-esi-abstract-ops-to-esi-physical-ops><code>-lower-esi-to-physical</code>: Lower ESI abstract Ops to ESI physical ops.</a></li><li><a href=#-lower-esi-types-lower-esi-high-level-types><code>-lower-esi-types</code>: Lower ESI high level types.</a></li></ul></li><li><a href=#firrtl-dialect-passes>FIRRTL Dialect Passes</a><ul><li><a href=#-firrtl-add-seqmem-ports-add-extra-ports-to-memory-modules><code>-firrtl-add-seqmem-ports</code>: Add extra ports to memory modules</a></li><li><a href=#-firrtl-blackbox-reader-load-source-files-for-black-boxes-into-the-ir><code>-firrtl-blackbox-reader</code>: Load source files for black boxes into the IR</a></li><li><a href=#-firrtl-check-comb-cycles-check-combinational-cycles-and-emit-errors><code>-firrtl-check-comb-cycles</code>: Check combinational cycles and emit errors</a></li><li><a href=#-firrtl-check-comb-loops-check-combinational-cycles-and-emit-errors><code>-firrtl-check-comb-loops</code>: Check combinational cycles and emit errors</a></li><li><a href=#-firrtl-dedup-deduplicate-modules-which-are-structurally-equivalent><code>-firrtl-dedup</code>: Deduplicate modules which are structurally equivalent</a></li><li><a href=#-firrtl-dft-wires-test-enables-to-clock-gates-for-dft-infrastructure><code>-firrtl-dft</code>: Wires test enables to clock gates for DFT infrastructure</a></li><li><a href=#-firrtl-drop-const-drop-const-modifier-from-types><code>-firrtl-drop-const</code>: Drop &lsquo;const&rsquo; modifier from types</a></li><li><a href=#-firrtl-drop-names-drop-interesting-names><code>-firrtl-drop-names</code>: Drop interesting names</a></li><li><a href=#-firrtl-emit-metadata-emit-metadata-of-the-firrtl-modules><code>-firrtl-emit-metadata</code>: Emit metadata of the FIRRTL modules</a></li><li><a href=#-firrtl-emit-omir-emit-omir-annotations><code>-firrtl-emit-omir</code>: Emit OMIR annotations</a></li><li><a href=#-firrtl-expand-whens-remove-all-when-conditional-blocks><code>-firrtl-expand-whens</code>: Remove all when conditional blocks.</a></li><li><a href=#-firrtl-extract-instances-move-annotated-instances-upwards-in-the-module-hierarchy><code>-firrtl-extract-instances</code>: Move annotated instances upwards in the module hierarchy</a></li><li><a href=#-firrtl-finalize-ir-perform-final-ir-mutations-after-exportverilog><code>-firrtl-finalize-ir</code>: Perform final IR mutations after ExportVerilog</a></li><li><a href=#-firrtl-flatten-memory-flatten-aggregate-memory-data-to-a-uint><code>-firrtl-flatten-memory</code>: Flatten aggregate memory data to a UInt</a></li><li><a href=#-firrtl-grand-central-remove-grand-central-annotations><code>-firrtl-grand-central</code>: Remove Grand Central Annotations</a></li><li><a href=#-firrtl-imconstprop-intermodule-constant-propagation-and-dead-code-elimination><code>-firrtl-imconstprop</code>: Intermodule constant propagation and dead code elimination</a></li><li><a href=#-firrtl-imdeadcodeelim-intermodule-dead-code-elimination><code>-firrtl-imdeadcodeelim</code>: Intermodule dead code elimination</a></li><li><a href=#-firrtl-infer-resets-infer-reset-synchronicity-and-add-implicit-resets><code>-firrtl-infer-resets</code>: Infer reset synchronicity and add implicit resets</a></li><li><a href=#-firrtl-infer-rw-infer-the-read-write-memory-port><code>-firrtl-infer-rw</code>: Infer the read-write memory port</a></li><li><a href=#-firrtl-infer-widths-infer-the-width-of-types><code>-firrtl-infer-widths</code>: Infer the width of types</a></li><li><a href=#-firrtl-inject-dut-hier-add-a-level-of-hierarchy-outside-the-dut><code>-firrtl-inject-dut-hier</code>: Add a level of hierarchy outside the DUT</a></li><li><a href=#-firrtl-inliner-performs-inlining-flattening-and-dead-module-elimination><code>-firrtl-inliner</code>: Performs inlining, flattening, and dead module elimination</a></li><li><a href=#-firrtl-inner-symbol-dce-eliminate-dead-inner-symbols><code>-firrtl-inner-symbol-dce</code>: Eliminate dead inner symbols</a></li><li><a href=#-firrtl-lower-annotations-lower-firrtl-annotations-to-usable-entities><code>-firrtl-lower-annotations</code>: Lower FIRRTL annotations to usable entities</a></li><li><a href=#-firrtl-lower-chirrtl-infer-the-memory-ports-of-seqmem-and-combmem><code>-firrtl-lower-chirrtl</code>: Infer the memory ports of SeqMem and CombMem</a></li><li><a href=#-firrtl-lower-intrinsics-lower-intrinsics><code>-firrtl-lower-intrinsics</code>: Lower intrinsics</a></li><li><a href=#-firrtl-lower-matches-remove-all-matchs-conditional-blocks><code>-firrtl-lower-matches</code>: Remove all matchs conditional blocks</a></li><li><a href=#-firrtl-lower-memory-lower-memories-to-generated-modules><code>-firrtl-lower-memory</code>: Lower memories to generated modules</a></li><li><a href=#-firrtl-lower-open-aggs-lower-open-aggregates-by-splitting-out-non-hardware-elements><code>-firrtl-lower-open-aggs</code>: Lower &lsquo;Open&rsquo; aggregates by splitting out non-hardware elements</a></li><li><a href=#-firrtl-lower-types-lower-firrtl-types-to-ground-types><code>-firrtl-lower-types</code>: Lower FIRRTL types to ground types</a></li><li><a href=#-firrtl-lower-xmr-lower-ref-ports-to-xmr><code>-firrtl-lower-xmr</code>: Lower ref ports to XMR</a></li><li><a href=#-firrtl-mem-to-reg-of-vec-convert-combinational-memories-to-a-vector-of-registers><code>-firrtl-mem-to-reg-of-vec</code>: Convert combinational memories to a vector of registers</a></li><li><a href=#-firrtl-prefix-modules-prefixes-names-of-modules-and-mems-in-a-hierarchy><code>-firrtl-prefix-modules</code>: Prefixes names of modules and mems in a hierarchy</a></li><li><a href=#-firrtl-print-field-source-print-field-source-information><code>-firrtl-print-field-source</code>: Print field source information.</a></li><li><a href=#-firrtl-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy><code>-firrtl-print-instance-graph</code>: Print a DOT graph of the module hierarchy.</a></li><li><a href=#-firrtl-print-nla-table-print-the-nla-table><code>-firrtl-print-nla-table</code>: Print the NLA Table.</a></li><li><a href=#-firrtl-randomize-register-init-randomize-register-initialization><code>-firrtl-randomize-register-init</code>: Randomize register initialization.</a></li><li><a href=#-firrtl-register-optimizer-optimizer-registers><code>-firrtl-register-optimizer</code>: Optimizer Registers</a></li><li><a href=#-firrtl-remove-unused-ports-remove-unused-ports><code>-firrtl-remove-unused-ports</code>: Remove unused ports</a></li><li><a href=#-firrtl-resolve-traces-write-out-traceannotations-to-an-output-annotation-file><code>-firrtl-resolve-traces</code>: Write out TraceAnnotations to an output annotation file</a></li><li><a href=#-firrtl-sfc-compat-perform-sfc-compatibility-fixes><code>-firrtl-sfc-compat</code>: Perform SFC Compatibility fixes</a></li><li><a href=#-firrtl-vb-to-bv-transform-vector-of-bundles-to-bundle-of-vectors><code>-firrtl-vb-to-bv</code>: Transform vector-of-bundles to bundle-of-vectors</a></li><li><a href=#-merge-connections-merge-field-level-connections-into-full-bundle-connections><code>-merge-connections</code>: Merge field-level connections into full bundle connections</a></li><li><a href=#-vectorization-transform-firrtl-primitive-operations-into-vector-operations><code>-vectorization</code>: Transform firrtl primitive operations into vector operations</a></li></ul></li><li><a href=#fsm-dialect-passes>FSM Dialect Passes</a><ul><li><a href=#-fsm-print-graph-print-a-dot-graph-of-the-module-hierarchy><code>-fsm-print-graph</code>: Print a DOT graph of the module hierarchy.</a></li></ul></li><li><a href=#handshake-dialect-passes>Handshake Dialect Passes</a><ul><li><a href=#-handshake-add-ids-add-an-id-to-each-operation-in-a-handshake-function><code>-handshake-add-ids</code>: Add an ID to each operation in a handshake function.</a></li><li><a href=#-handshake-dematerialize-forks-sinks-dematerialize-fork-and-sink-operations><code>-handshake-dematerialize-forks-sinks</code>: Dematerialize fork and sink operations.</a></li><li><a href=#-handshake-insert-buffers-insert-buffers-to-break-graph-cycles><code>-handshake-insert-buffers</code>: Insert buffers to break graph cycles</a></li><li><a href=#-handshake-legalize-memrefs-memref-legalization-and-lowering-pass><code>-handshake-legalize-memrefs</code>: Memref legalization and lowering pass.</a></li><li><a href=#-handshake-lock-functions-lock-each-function-to-only-allow-single-invocations><code>-handshake-lock-functions</code>: Lock each function to only allow single invocations.</a></li><li><a href=#-handshake-lower-extmem-to-hw-lowers-handshakeextmem-and-memref-inputs-to-ports><code>-handshake-lower-extmem-to-hw</code>: Lowers handshake.extmem and memref inputs to ports.</a></li><li><a href=#-handshake-materialize-forks-sinks-materialize-fork-and-sink-operations><code>-handshake-materialize-forks-sinks</code>: Materialize fork and sink operations.</a></li><li><a href=#-handshake-op-count-count-the-number-of-operations-resources-in-a-handshake-function><code>-handshake-op-count</code>: Count the number of operations (resources) in a handshake function.</a></li><li><a href=#-handshake-print-dot-print-dot-graph-of-a-handshake-function><code>-handshake-print-dot</code>: Print .dot graph of a handshake function.</a></li><li><a href=#-handshake-remove-buffers-remove-buffers-from-handshake-functions><code>-handshake-remove-buffers</code>: Remove buffers from handshake functions.</a></li></ul></li><li><a href=#hw-dialect-passes>HW Dialect Passes</a><ul><li><a href=#-hw-flatten-io-flattens-hwstructure-typed-in--and-output-ports><code>-hw-flatten-io</code>: Flattens hw::Structure typed in- and output ports.</a></li><li><a href=#-hw-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy><code>-hw-print-instance-graph</code>: Print a DOT graph of the module hierarchy.</a></li><li><a href=#-hw-print-module-graph-print-a-dot-graph-of-the-hwmodules-within-a-top-level-module><code>-hw-print-module-graph</code>: Print a DOT graph of the HWModule&rsquo;s within a top-level module.</a></li><li><a href=#-hw-specialize-specializes-instances-of-parametric-hwmodules><code>-hw-specialize</code>: Specializes instances of parametric hw.modules</a></li></ul></li><li><a href=#llhd-dialect-passes>LLHD Dialect Passes</a><ul><li><a href=#-llhd-early-code-motion-move-side-effect-free-instructions-and-llhdprb-up-in-the-cfg><code>-llhd-early-code-motion</code>: Move side-effect-free instructions and llhd.prb up in the CFG</a></li><li><a href=#-llhd-function-elimination-deletes-all-functions><code>-llhd-function-elimination</code>: Deletes all functions.</a></li><li><a href=#-llhd-memory-to-block-argument-promote-memory-to-block-arguments><code>-llhd-memory-to-block-argument</code>: Promote memory to block arguments.</a></li><li><a href=#-llhd-process-lowering-lowers-llhd-processes-to-entities><code>-llhd-process-lowering</code>: Lowers LLHD Processes to Entities.</a></li></ul></li><li><a href=#msft-dialect-passes>MSFT Dialect Passes</a><ul><li><a href=#-lower-msft-to-hw-lower-msft-ops-to-hw-ops><code>-lower-msft-to-hw</code>: Lower MSFT ops to hw ops</a></li><li><a href=#-msft-discover-appids-discover-the-appids-in-a-module-hierarchy><code>-msft-discover-appids</code>: Discover the appids in a module hierarchy</a></li><li><a href=#-msft-export-tcl-create-tcl-ops><code>-msft-export-tcl</code>: Create tcl ops</a></li><li><a href=#-msft-lower-constructs-lower-high-level-constructs><code>-msft-lower-constructs</code>: Lower high-level constructs</a></li><li><a href=#-msft-lower-instances-lower-dynamic-instances><code>-msft-lower-instances</code>: Lower dynamic instances</a></li><li><a href=#-msft-partition-move-the-entities-targeted-for-a-design-partition><code>-msft-partition</code>: Move the entities targeted for a design partition</a></li><li><a href=#-msft-wire-cleanup-cleanup-unnecessary-ports-and-wires><code>-msft-wire-cleanup</code>: Cleanup unnecessary ports and wires</a></li></ul></li><li><a href=#pipeline-dialect-passes>Pipeline Dialect Passes</a><ul><li><a href=#-pipeline-explicit-regs-makes-stage-registers-explicit><code>-pipeline-explicit-regs</code>: Makes stage registers explicit.</a></li><li><a href=#-pipeline-schedule-linear-schedules-a-linear-pipeline><code>-pipeline-schedule-linear</code>: Schedules a linear pipeline.</a></li></ul></li><li><a href=#seq-dialect-passes>Seq Dialect Passes</a><ul><li><a href=#-lower-seq-firrtl-init-to-sv-prep-the-module-with-macro-definitions-for-firrtl-registers><code>-lower-seq-firrtl-init-to-sv</code>: Prep the module with macro definitions for firrtl registers.</a></li><li><a href=#-lower-seq-firrtl-to-sv-lower-sequential-firrtl-ops-to-sv><code>-lower-seq-firrtl-to-sv</code>: Lower sequential firrtl ops to SV.</a></li><li><a href=#-lower-seq-hlmem-lowers-seqhlmem-operations><code>-lower-seq-hlmem</code>: Lowers seq.hlmem operations.</a></li><li><a href=#-lower-seq-to-sv-lower-sequential-ops-to-sv><code>-lower-seq-to-sv</code>: Lower sequential ops to SV.</a></li></ul></li><li><a href=#ssp-dialect-passes>SSP Dialect Passes</a><ul><li><a href=#-ssp-print-prints-all-ssp-instances-as-dot-graphs><code>-ssp-print</code>: Prints all SSP instances as DOT graphs.</a></li><li><a href=#-ssp-roundtrip-roundtrips-all-ssp-instances-via-the-scheduling-infrastructure><code>-ssp-roundtrip</code>: Roundtrips all SSP instances via the scheduling infrastructure</a></li><li><a href=#-ssp-schedule-schedules-all-ssp-instances><code>-ssp-schedule</code>: Schedules all SSP instances.</a></li></ul></li><li><a href=#sv-dialect-passes>SV Dialect Passes</a><ul><li><a href=#-hw-cleanup-cleanup-transformations-for-operations-in-hwmodule-bodies><code>-hw-cleanup</code>: Cleanup transformations for operations in hw.module bodies</a></li><li><a href=#-hw-export-module-hierarchy-export-module-and-instance-hierarchy-information><code>-hw-export-module-hierarchy</code>: Export module and instance hierarchy information</a></li><li><a href=#-hw-generator-callout-lower-generator-schema-to-external-module><code>-hw-generator-callout</code>: Lower Generator Schema to external module</a></li><li><a href=#-hw-legalize-modules-eliminate-features-marked-unsupported-in-loweringoptions><code>-hw-legalize-modules</code>: Eliminate features marked unsupported in LoweringOptions</a></li><li><a href=#-hw-memory-sim-implement-firrtmmem-memories-nodes-with-simulation-model><code>-hw-memory-sim</code>: Implement FIRRTMMem memories nodes with simulation model</a></li><li><a href=#-hw-stub-external-modules-transform-external-hw-modules-to-empty-hw-modules><code>-hw-stub-external-modules</code>: transform external hw modules to empty hw modules</a></li><li><a href=#-prettify-verilog-transformations-to-improve-quality-of-exportverilog-output><code>-prettify-verilog</code>: Transformations to improve quality of ExportVerilog output</a></li><li><a href=#-sv-extract-test-code-extract-simulation-only-constructs-to-modules-and-bind><code>-sv-extract-test-code</code>: Extract simulation only constructs to modules and bind</a></li><li><a href=#-sv-trace-iverilog-add-tracing-to-an-iverilog-simulated-module><code>-sv-trace-iverilog</code>: Add tracing to an iverilog simulated module</a></li></ul></li><li><a href=#systemc-dialect-passes>SystemC Dialect Passes</a><ul><li><a href=#-systemc-lower-instance-interop-lower-all-systemc-instance-interop-operations><code>-systemc-lower-instance-interop</code>: Lower all SystemC instance interop operations.</a></li></ul></li></ul></nav><h2 id=conversion-passes>Conversion Passes&nbsp;<a class=headline-hash href=#conversion-passes>¶</a></h2><h3 id=-calyx-remove-groups-fsm-perform-fsm-outlining-and-group-removal><code>-calyx-remove-groups-fsm</code>: Perform FSM outlining and group removal&nbsp;<a class=headline-hash href=#-calyx-remove-groups-fsm-perform-fsm-outlining-and-group-removal>¶</a></h3><p>This pass will outline the FSM into module scope and replace any SSA value references
from within the FSM body with additional inputs. Given this, the FSM
is instantiated as a <code>fsm.hw_module</code> operation within the Calyx component.
Using the FSM I/O (which is the group go/done signals), the <code>calyx.group</code>
operations are removed from the component, with the group go and done signals
being wired up to the FSM instance.
Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>calyx<span class=p>.</span>component <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%reg</span><span class=p>,</span> <span class=nl>... =</span> calyx<span class=p>.</span>register <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>wires <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// Groups have explicit done signals, and assignments are not guarded
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// by a group go signal.
</span></span></span><span class=line><span class=cl><span class=c></span>        calyx<span class=p>.</span>group <span class=nf>@A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>...</span>
</span></span><span class=line><span class=cl>            calyx<span class=p>.</span>assign <span class=nv>%reg</span> <span class=p>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=p>...</span>
</span></span><span class=line><span class=cl>            calyx<span class=p>.</span>group_done <span class=nv>%foo</span> <span class=err>?</span> <span class=nv>%bar</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>control <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// Machine is defined inside the `calyx.control` operation and references
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// SSA values defined outside the machine.
</span></span></span><span class=line><span class=cl><span class=c></span>        fsm<span class=p>.</span>machine <span class=nf>@control</span><span class=p>(</span><span class=nv>%A_done</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%A_go</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>not <span class=nv>%reg</span> <span class=c>// reference some SSA value defined outside the machine
</span></span></span><span class=line><span class=cl><span class=c></span>            <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>into</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// The machine has been outlined into module scope, and no longer references
</span></span></span><span class=line><span class=cl><span class=c>// any SSA values defined outside the machine. It is now fully independent
</span></span></span><span class=line><span class=cl><span class=c>// from any notion of Calyx.
</span></span></span><span class=line><span class=cl><span class=c></span>fsm<span class=p>.</span>machine <span class=nf>@control</span><span class=p>(</span><span class=nv>%A_done</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%reg</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%A_go</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>not <span class=nv>%reg</span> <span class=c>// reference some SSA value defined outside the machine
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>calyx<span class=p>.</span>component <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%reg</span><span class=p>,</span> <span class=nl>... =</span> calyx<span class=p>.</span>register <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c>// Done signals are now wires
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%A_done_in</span><span class=p>,</span> <span class=nv>%A_done_out</span> <span class=p>=</span> calyx<span class=p>.</span>wire <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>    <span class=c>// The FSM is now instantiated as an `fsm.hwinstance` module
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%A_go</span> <span class=p>=</span> fsm<span class=p>.</span>hwinstance <span class=nf>@control</span><span class=p>(</span><span class=nv>%A_done_out</span><span class=p>,</span> <span class=nv>%reg</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>wires <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// Groups have been inlined, the group go signal is now a guard for
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// all assignments, and `calyx.group_done` operations have been
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// replaced by wire assignments.
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        calyx<span class=p>.</span>assign <span class=nv>%reg</span> <span class=p>=</span> <span class=nv>%A_go</span> <span class=err>?</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        calyx<span class=p>.</span>assign <span class=nv>%A_done_in</span> <span class=p>=</span> <span class=nv>%foo</span> <span class=err>?</span> <span class=nv>%bar</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>control <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-convert-affine-to-loopschedule-convert-affine-dialect-to-loopschedule-scheduled-loops><code>-convert-affine-to-loopschedule</code>: Convert Affine dialect to LoopSchedule scheduled loops&nbsp;<a class=headline-hash href=#-convert-affine-to-loopschedule-convert-affine-dialect-to-loopschedule-scheduled-loops>¶</a></h3><p>This pass analyzes Affine loops and control flow, creates a Scheduling
problem using the Calyx operator library, solves the problem, and lowers
the loops to a LoopSchedule.</p><h3 id=-convert-comb-to-arith-convert-combinational-ops-and-constants-into-arith-ops><code>-convert-comb-to-arith</code>: Convert combinational ops and constants into arith ops&nbsp;<a class=headline-hash href=#-convert-comb-to-arith-convert-combinational-ops-and-constants-into-arith-ops>¶</a></h3><h3 id=-convert-fsm-to-sv-convert-fsm-to-hw><code>-convert-fsm-to-sv</code>: Convert FSM to HW&nbsp;<a class=headline-hash href=#-convert-fsm-to-sv-convert-fsm-to-hw>¶</a></h3><h3 id=-convert-hw-to-llhd-convert-hw-to-llhd><code>-convert-hw-to-llhd</code>: Convert HW to LLHD&nbsp;<a class=headline-hash href=#-convert-hw-to-llhd-convert-hw-to-llhd>¶</a></h3><p>This pass translates a HW design into an equivalent structural LLHD
description.</p><h3 id=-convert-hw-to-llvm-convert-hw-to-llvm><code>-convert-hw-to-llvm</code>: Convert HW to LLVM&nbsp;<a class=headline-hash href=#-convert-hw-to-llvm-convert-hw-to-llvm>¶</a></h3><p>This pass translates HW to LLVM.</p><h3 id=-convert-hw-to-systemc-convert-hw-to-systemc><code>-convert-hw-to-systemc</code>: Convert HW to SystemC&nbsp;<a class=headline-hash href=#-convert-hw-to-systemc-convert-hw-to-systemc>¶</a></h3><p>This pass translates a HW design into an equivalent SystemC design.</p><h3 id=-convert-llhd-to-llvm-convert-llhd-to-llvm><code>-convert-llhd-to-llvm</code>: Convert LLHD to LLVM&nbsp;<a class=headline-hash href=#-convert-llhd-to-llvm-convert-llhd-to-llvm>¶</a></h3><p>This pass translates LLHD to LLVM.</p><h3 id=-convert-moore-to-core-convert-moore-to-core><code>-convert-moore-to-core</code>: Convert Moore to Core&nbsp;<a class=headline-hash href=#-convert-moore-to-core-convert-moore-to-core>¶</a></h3><p>This pass translates Moore to the core dialects (Comb/HW/LLHD).</p><h3 id=-convert-to-arcs-outline-logic-between-registers-into-state-transfer-arcs><code>-convert-to-arcs</code>: Outline logic between registers into state transfer arcs&nbsp;<a class=headline-hash href=#-convert-to-arcs-outline-logic-between-registers-into-state-transfer-arcs>¶</a></h3><p>This pass outlines combinational logic between registers into state transfer
arc definitions. The the original combinational logic and register is
replaced with an arc invocation, where the register is now represented as a
latency.</p><h3 id=-export-chisel-interface-emit-a-chisel-interface-to-a-firrtl-circuit><code>-export-chisel-interface</code>: Emit a Chisel interface to a FIRRTL circuit&nbsp;<a class=headline-hash href=#-export-chisel-interface-emit-a-chisel-interface-to-a-firrtl-circuit>¶</a></h3><p>This pass generates a Scala Chisel interface for the top level module of
a FIRRTL circuit.</p><h3 id=-export-split-chisel-interface-emit-a-chisel-interface-to-a-firrtl-circuit-to-a-directory-of-files><code>-export-split-chisel-interface</code>: Emit a Chisel interface to a FIRRTL circuit to a directory of files&nbsp;<a class=headline-hash href=#-export-split-chisel-interface-emit-a-chisel-interface-to-a-firrtl-circuit-to-a-directory-of-files>¶</a></h3><p>This pass generates a Scala Chisel interface for the top level module of
a FIRRTL circuit.</p><h4 id=options>Options&nbsp;<a class=headline-hash href=#options>¶</a></h4><pre tabindex=0><code>-dir-name : Directory to emit into
</code></pre><h3 id=-export-split-verilog-emit-the-ir-to-a-systemverilog-directory-of-files><code>-export-split-verilog</code>: Emit the IR to a (System)Verilog directory of files&nbsp;<a class=headline-hash href=#-export-split-verilog-emit-the-ir-to-a-systemverilog-directory-of-files>¶</a></h3><p>This pass generates (System)Verilog for the current design, mutating it
where necessary to be valid Verilog.</p><h4 id=options-1>Options&nbsp;<a class=headline-hash href=#options-1>¶</a></h4><pre tabindex=0><code>-dir-name : Directory to emit into
</code></pre><h3 id=-export-verilog-emit-the-ir-to-a-systemverilog-file><code>-export-verilog</code>: Emit the IR to a (System)Verilog file&nbsp;<a class=headline-hash href=#-export-verilog-emit-the-ir-to-a-systemverilog-file>¶</a></h3><p>This pass creates empty module bodies for external modules. This is
useful for linting to eliminate missing file errors.</p><h3 id=-handshake-remove-block-structure-remove-block-structure-in-handshake-ir><code>-handshake-remove-block-structure</code>: Remove block structure in Handshake IR&nbsp;<a class=headline-hash href=#-handshake-remove-block-structure-remove-block-structure-in-handshake-ir>¶</a></h3><h3 id=-insert-merge-blocks-insert-explicit-merge-blocks><code>-insert-merge-blocks</code>: Insert explicit merge blocks&nbsp;<a class=headline-hash href=#-insert-merge-blocks-insert-explicit-merge-blocks>¶</a></h3><p>This pass inserts additional merge blocks for each block with more than
two successors. A merge block is a block that only contains one operation,
a terminator, and has two predecessors.
The order successors are merged together mirrors the order different control
paths are created. Thus, each block with two successors will have a corresponding
merge block.</p><p>This pass brings the CFG into a canonical form for further transformations.</p><p>Treats loops and sub-CFGs with irregular control flow like single blocks.</p><h3 id=-legalize-anon-enums-prepare-anonymous-enumeration-types-for-exportverilog><code>-legalize-anon-enums</code>: Prepare anonymous enumeration types for ExportVerilog&nbsp;<a class=headline-hash href=#-legalize-anon-enums-prepare-anonymous-enumeration-types-for-exportverilog>¶</a></h3><p>This pass transforms all anonymous enumeration types into typedecls to work
around difference in how anonymous enumerations work in SystemVerilog.</p><h3 id=-lower-arc-to-llvm-lower-state-transfer-arc-representation-to-llvm><code>-lower-arc-to-llvm</code>: Lower state transfer arc representation to LLVM&nbsp;<a class=headline-hash href=#-lower-arc-to-llvm-lower-state-transfer-arc-representation-to-llvm>¶</a></h3><h3 id=-lower-calyx-to-fsm-lower-calyx-to-fsm><code>-lower-calyx-to-fsm</code>: Lower Calyx to FSM&nbsp;<a class=headline-hash href=#-lower-calyx-to-fsm-lower-calyx-to-fsm>¶</a></h3><p>This pass lowers a Calyx control schedule to an FSM representation.
An <code>fsm.machine</code> operation is nested within the <code>control</code> region of the Calyx
component. This machine is itself in an intermediate format wherein it has
no I/O ports and solely contains output statements with <code>calyx.enable</code>s
referencing <code>calyx.group</code> and transition logic guarded by the SSA values
specified in the source control schedule.
This intermediate state facilitates transformation of the FSM, given that
top-level I/O has yet to be materialized (one input and output per activated
group) as well as guard transition logic (every transition must be guarded
on all groups active within the state having finished). As such, <code>calyx.enable</code>
operations can easily be moved between states without worrying about updating
transition guards while doing so.</p><p>Eventually, the FSM must be materialized (materialize I/O ports, remove
<code>calyx.enable</code> operations in favor of asserting output ports, guarding
transitions by input <code>done</code> ports) and outlined to a separate module.</p><h3 id=-lower-calyx-to-hw-lower-calyx-to-hw><code>-lower-calyx-to-hw</code>: Lower Calyx to HW&nbsp;<a class=headline-hash href=#-lower-calyx-to-hw-lower-calyx-to-hw>¶</a></h3><p>This pass lowers Calyx to HW.</p><h3 id=-lower-firrtl-to-hw-lower-firrtl-to-hw><code>-lower-firrtl-to-hw</code>: Lower FIRRTL to HW&nbsp;<a class=headline-hash href=#-lower-firrtl-to-hw-lower-firrtl-to-hw>¶</a></h3><p>Lower a module of FIRRTL dialect to the HW dialect family.</p><h4 id=options-2>Options&nbsp;<a class=headline-hash href=#options-2>¶</a></h4><pre tabindex=0><code>-disable-mem-randomization       : Disable emission of memory randomization code
-disable-reg-randomization       : Disable emission of register randomization code
-warn-on-unprocessed-annotations : Emit warnings on unprocessed annotations during lower-to-hw pass
-emit-chisel-asserts-as-sva      : Convert all Chisel asserts to SVA
-add-mux-pragmas                 : Annotate mux pragmas to multibit mux and subacess results
</code></pre><h3 id=-lower-handshake-to-dc-lower-handshake-to-dc><code>-lower-handshake-to-dc</code>: Lower Handshake to DC&nbsp;<a class=headline-hash href=#-lower-handshake-to-dc-lower-handshake-to-dc>¶</a></h3><p>Lower Handshake to DC operations.
Currently, a <code>handshake.func</code> will be converted into a <code>hw.module</code>. This
is principally an incorrect jump of abstraction - DC does not imply any
RTL/hardware semantics. However, DC does not define a container operation,
and there does not exist an e.g. <code>func.graph_func</code> which would be a generic
function with graph region behaviour. Thus, for now, we just use <code>hw.module</code>
as a container operation.</p><h3 id=-lower-handshake-to-hw-lower-handshake-to-esihwcombseq><code>-lower-handshake-to-hw</code>: Lower Handshake to ESI/HW/Comb/Seq&nbsp;<a class=headline-hash href=#-lower-handshake-to-hw-lower-handshake-to-esihwcombseq>¶</a></h3><p>Lower Handshake to ESI/HW/Comb/Seq.</p><h3 id=-lower-hwarith-to-hw-lower-hwarith-to-hwcomb><code>-lower-hwarith-to-hw</code>: Lower HWArith to HW/Comb&nbsp;<a class=headline-hash href=#-lower-hwarith-to-hw-lower-hwarith-to-hwcomb>¶</a></h3><p>This pass lowers HWArith to HW/Comb.</p><h3 id=-lower-loopschedule-to-calyx-lower-loopschedule-to-calyx><code>-lower-loopschedule-to-calyx</code>: Lower LoopSchedule to Calyx&nbsp;<a class=headline-hash href=#-lower-loopschedule-to-calyx-lower-loopschedule-to-calyx>¶</a></h3><p>This pass lowers LoopSchedule to Calyx.</p><h4 id=options-3>Options&nbsp;<a class=headline-hash href=#options-3>¶</a></h4><pre tabindex=0><code>-top-level-function             : Identifier of top-level function to be the entry-point component of the Calyx program.
-cider-source-location-metadata : Whether to track source location for the Cider debugger.
</code></pre><h3 id=-lower-pipeline-to-hw-lower-pipeline-to-hw><code>-lower-pipeline-to-hw</code>: Lower Pipeline to HW&nbsp;<a class=headline-hash href=#-lower-pipeline-to-hw-lower-pipeline-to-hw>¶</a></h3><p>This pass lowers <code>pipeline.rtp</code> operations to HW.</p><h3 id=-lower-scf-to-calyx-lower-scfstandard-to-calyx><code>-lower-scf-to-calyx</code>: Lower SCF/Standard to Calyx&nbsp;<a class=headline-hash href=#-lower-scf-to-calyx-lower-scfstandard-to-calyx>¶</a></h3><p>This pass lowers SCF / standard to Calyx.</p><h4 id=options-4>Options&nbsp;<a class=headline-hash href=#options-4>¶</a></h4><pre tabindex=0><code>-top-level-function             : Identifier of top-level function to be the entry-point component of the Calyx program.
-cider-source-location-metadata : Whether to track source location for the Cider debugger.
</code></pre><h3 id=-lower-std-to-handshake-lower-standard-mlir-into-handshake-ir><code>-lower-std-to-handshake</code>: Lower Standard MLIR into Handshake IR&nbsp;<a class=headline-hash href=#-lower-std-to-handshake-lower-standard-mlir-into-handshake-ir>¶</a></h3><h4 id=options-5>Options&nbsp;<a class=headline-hash href=#options-5>¶</a></h4><pre tabindex=0><code>-source-constants        : If true, will connect constants to source operations instead of to the control network. May reduce the size of the final circuit.
-disable-task-pipelining : If true, will disable support for task pipelining. This relaxes the restrictions put on the structure of the input CDFG. Disabling task pipelining may severely reduce kernel II.
</code></pre><h3 id=-materialize-calyx-to-fsm-materializes-an-fsm-embedded-inside-the-control-of-this-calyx-component><code>-materialize-calyx-to-fsm</code>: Materializes an FSM embedded inside the control of this Calyx component.&nbsp;<a class=headline-hash href=#-materialize-calyx-to-fsm-materializes-an-fsm-embedded-inside-the-control-of-this-calyx-component>¶</a></h3><p>Materializes the FSM in the control of the component. This materializes the
top-level I/O of the FSM to receive <code>group_done</code> signals as input and
<code>group_go</code> signals as output, based on the <code>calyx.enable</code> operations
used within the states of the FSM.
Each transition of the FSM is predicated on the enabled groups within a
state being done, or, for static groups, a separate sub-FSM is instantiated
to await the group finishing.</p><p>Given an FSM that enables N unique groups, the top-level FSM will have N+1
in- and output ports, wherein:</p><ul><li>Input # 0 to N-1 are <code>group_done</code> signals</li><li>Input N is the top-level <code>go</code> port</li><li>Output 0 to N-1 are <code>group_go</code> signals</li><li>Output N is the top-level <code>done</code> port</li></ul><h3 id=-maximize-ssa-convert-every-function-in-the-module-into-maximal-ssa-form><code>-maximize-ssa</code>: Convert every function in the module into maximal SSA form&nbsp;<a class=headline-hash href=#-maximize-ssa-convert-every-function-in-the-module-into-maximal-ssa-form>¶</a></h3><p>Convert the region within every function into maximal SSA form. This
ensures that every value used within a block is also defined within the
block, making dataflow explicit and removing block dominance-based dataflow
semantics. The pass achieves this by adding block arguments wherever
necessary to forward values to the block(s) where they are used.</p><h3 id=-prepare-for-emission-prepare-ir-for-exportverilog><code>-prepare-for-emission</code>: Prepare IR for ExportVerilog&nbsp;<a class=headline-hash href=#-prepare-for-emission-prepare-ir-for-exportverilog>¶</a></h3><p>This pass runs only PrepareForEmission.
It is not necessary for users to run this pass explicitly since
ExportVerilog internally runs PrepareForEmission.</p><h3 id=-test-apply-lowering-options-apply-lowering-options><code>-test-apply-lowering-options</code>: Apply lowering options&nbsp;<a class=headline-hash href=#-test-apply-lowering-options-apply-lowering-options>¶</a></h3><p>This pass allows overriding lowering options. It is intended for test
construction.</p><h4 id=options-6>Options&nbsp;<a class=headline-hash href=#options-6>¶</a></h4><pre tabindex=0><code>-options : Lowering Options
</code></pre><h2 id=arc-dialect-passes>Arc Dialect Passes&nbsp;<a class=headline-hash href=#arc-dialect-passes>¶</a></h2><h3 id=-arc-add-taps-add-taps-to-ports-and-wires-such-that-they-remain-observable><code>-arc-add-taps</code>: Add taps to ports and wires such that they remain observable&nbsp;<a class=headline-hash href=#-arc-add-taps-add-taps-to-ports-and-wires-such-that-they-remain-observable>¶</a></h3><h4 id=options-7>Options&nbsp;<a class=headline-hash href=#options-7>¶</a></h4><pre tabindex=0><code>-ports        : Make module ports observable
-wires        : Make wires observable
-named-values : Make values with `sv.namehint` observable
</code></pre><h3 id=-arc-allocate-state-allocate-and-layout-the-global-simulation-state><code>-arc-allocate-state</code>: Allocate and layout the global simulation state&nbsp;<a class=headline-hash href=#-arc-allocate-state-allocate-and-layout-the-global-simulation-state>¶</a></h3><h3 id=-arc-canonicalizer-simulation-centric-canonicalizations><code>-arc-canonicalizer</code>: Simulation centric canonicalizations&nbsp;<a class=headline-hash href=#-arc-canonicalizer-simulation-centric-canonicalizations>¶</a></h3><h4 id=statistics>Statistics&nbsp;<a class=headline-hash href=#statistics>¶</a></h4><pre tabindex=0><code>num-arc-args-removed : Number of arguments removed from DefineOps
</code></pre><h3 id=-arc-dedup-deduplicate-identical-arc-definitions><code>-arc-dedup</code>: Deduplicate identical arc definitions&nbsp;<a class=headline-hash href=#-arc-dedup-deduplicate-identical-arc-definitions>¶</a></h3><p>This pass deduplicates identical arc definitions. If two arcs differ only by
constants, the constants are outlined such that the arc can be deduplicated.</p><h3 id=-arc-group-resets-and-enables-group-reset-and-enable-conditions-of-lowered-states><code>-arc-group-resets-and-enables</code>: Group reset and enable conditions of lowered states&nbsp;<a class=headline-hash href=#-arc-group-resets-and-enables-group-reset-and-enable-conditions-of-lowered-states>¶</a></h3><h3 id=-arc-infer-memories-convert-firrtl_memory-instances-to-dedicated-memory-ops><code>-arc-infer-memories</code>: Convert <code>FIRRTL_Memory</code> instances to dedicated memory ops&nbsp;<a class=headline-hash href=#-arc-infer-memories-convert-firrtl_memory-instances-to-dedicated-memory-ops>¶</a></h3><h3 id=-arc-infer-state-properties-add-resets-and-enables-explicitly-to-the-state-operations><code>-arc-infer-state-properties</code>: Add resets and enables explicitly to the state operations&nbsp;<a class=headline-hash href=#-arc-infer-state-properties-add-resets-and-enables-explicitly-to-the-state-operations>¶</a></h3><h3 id=-arc-inline-inline-very-small-arcs><code>-arc-inline</code>: Inline very small arcs&nbsp;<a class=headline-hash href=#-arc-inline-inline-very-small-arcs>¶</a></h3><h4 id=options-8>Options&nbsp;<a class=headline-hash href=#options-8>¶</a></h4><pre tabindex=0><code>-into-arcs-only : Call operations to inline
-max-body-ops   : Max number of non-trivial ops in the region to be inlined
</code></pre><h4 id=statistics-1>Statistics&nbsp;<a class=headline-hash href=#statistics-1>¶</a></h4><pre tabindex=0><code>inlined-arcs    : Arcs inlined at a use site
removed-arcs    : Arcs removed after full inlining
trivial-arcs    : Arcs with very few ops
single-use-arcs : Arcs with a single use
</code></pre><h3 id=-arc-inline-modules-eagerly-inline-private-modules><code>-arc-inline-modules</code>: Eagerly inline private modules&nbsp;<a class=headline-hash href=#-arc-inline-modules-eagerly-inline-private-modules>¶</a></h3><p>This pass eagerly inlines private HW modules into their instantiation sites.
After outlining combinational logic and registers into arcs, module bodies
become fairly lightweight. Since arc definitions now fulfill the purpose of
code reuse by allowing a single definition to be called multiple times, the
module hierarchy degenerates into a purely cosmetic construct. At that point
it is beneficial to fully flatten the module hierarchy to simplify further
analysis and optimization of state transfer arcs.</p><h3 id=-arc-isolate-clocks-group-clocked-operations-into-clock-domains><code>-arc-isolate-clocks</code>: Group clocked operations into clock domains&nbsp;<a class=headline-hash href=#-arc-isolate-clocks-group-clocked-operations-into-clock-domains>¶</a></h3><h3 id=-arc-latency-retiming-push-latencies-through-the-design><code>-arc-latency-retiming</code>: Push latencies through the design&nbsp;<a class=headline-hash href=#-arc-latency-retiming-push-latencies-through-the-design>¶</a></h3><h4 id=statistics-2>Statistics&nbsp;<a class=headline-hash href=#statistics-2>¶</a></h4><pre tabindex=0><code>num-ops-removed     : Number of zero-latency passthrough states removed
latency-units-saved : Number of latency units saved by merging them in a successor state
</code></pre><h3 id=-arc-legalize-state-update-insert-temporaries-such-that-state-reads-dont-see-writes><code>-arc-legalize-state-update</code>: Insert temporaries such that state reads don&rsquo;t see writes&nbsp;<a class=headline-hash href=#-arc-legalize-state-update-insert-temporaries-such-that-state-reads-dont-see-writes>¶</a></h3><h3 id=-arc-lower-clocks-to-funcs-lower-clock-trees-into-functions><code>-arc-lower-clocks-to-funcs</code>: Lower clock trees into functions&nbsp;<a class=headline-hash href=#-arc-lower-clocks-to-funcs-lower-clock-trees-into-functions>¶</a></h3><h3 id=-arc-lower-lut-lowers-arclut-into-a-comb-and-hw-only-representation><code>-arc-lower-lut</code>: Lowers arc.lut into a comb and hw only representation.&nbsp;<a class=headline-hash href=#-arc-lower-lut-lowers-arclut-into-a-comb-and-hw-only-representation>¶</a></h3><h3 id=-arc-lower-state-split-state-into-read-and-write-ops-grouped-by-clock-tree><code>-arc-lower-state</code>: Split state into read and write ops grouped by clock tree&nbsp;<a class=headline-hash href=#-arc-lower-state-split-state-into-read-and-write-ops-grouped-by-clock-tree>¶</a></h3><h3 id=-arc-make-tables-transform-appropriate-arc-logic-into-lookup-tables><code>-arc-make-tables</code>: Transform appropriate arc logic into lookup tables&nbsp;<a class=headline-hash href=#-arc-make-tables-transform-appropriate-arc-logic-into-lookup-tables>¶</a></h3><h3 id=-arc-mux-to-control-flow-convert-muxes-with-large-independent-fan-ins-to-if-statements><code>-arc-mux-to-control-flow</code>: Convert muxes with large independent fan-ins to if-statements&nbsp;<a class=headline-hash href=#-arc-mux-to-control-flow-convert-muxes-with-large-independent-fan-ins-to-if-statements>¶</a></h3><h3 id=-arc-print-state-info-print-the-state-storage-layout-in-json-format><code>-arc-print-state-info</code>: Print the state storage layout in JSON format&nbsp;<a class=headline-hash href=#-arc-print-state-info-print-the-state-storage-layout-in-json-format>¶</a></h3><h4 id=options-9>Options&nbsp;<a class=headline-hash href=#options-9>¶</a></h4><pre tabindex=0><code>-state-file : Emit file with state description
</code></pre><h3 id=-arc-simplify-variadic-ops-convert-variadic-ops-into-distributed-binary-ops><code>-arc-simplify-variadic-ops</code>: Convert variadic ops into distributed binary ops&nbsp;<a class=headline-hash href=#-arc-simplify-variadic-ops-convert-variadic-ops-into-distributed-binary-ops>¶</a></h3><h4 id=statistics-3>Statistics&nbsp;<a class=headline-hash href=#statistics-3>¶</a></h4><pre tabindex=0><code>skipped-multiple-blocks : Ops skipped due to operands in different blocks
simplified              : Ops simplified into binary ops
created                 : Ops created as part of simplification
reordered               : Ops where simplification reordered operands
</code></pre><h3 id=-arc-split-loops-split-arcs-to-break-zero-latency-loops><code>-arc-split-loops</code>: Split arcs to break zero latency loops&nbsp;<a class=headline-hash href=#-arc-split-loops-split-arcs-to-break-zero-latency-loops>¶</a></h3><h3 id=-arc-strip-sv-remove-sv-wire-reg-and-assigns><code>-arc-strip-sv</code>: Remove SV wire, reg, and assigns&nbsp;<a class=headline-hash href=#-arc-strip-sv-remove-sv-wire-reg-and-assigns>¶</a></h3><h4 id=options-10>Options&nbsp;<a class=headline-hash href=#options-10>¶</a></h4><pre tabindex=0><code>-replace-ext-module-outputs : When enabled replaces all extern module instance outputs with 0 and removes the instances and external modules
</code></pre><h2 id=calyx-dialect-passes>Calyx Dialect Passes&nbsp;<a class=headline-hash href=#calyx-dialect-passes>¶</a></h2><h3 id=-calyx-clk-insertion-inserts-assignments-from-component-clock-to-sub-component-clock><code>-calyx-clk-insertion</code>: Inserts assignments from component clock to sub-component clock.&nbsp;<a class=headline-hash href=#-calyx-clk-insertion-inserts-assignments-from-component-clock-to-sub-component-clock>¶</a></h3><h3 id=-calyx-compile-control-generates-latency-insensitive-finite-state-machines-to-realize-control><code>-calyx-compile-control</code>: Generates latency-insensitive finite state machines to realize control.&nbsp;<a class=headline-hash href=#-calyx-compile-control-generates-latency-insensitive-finite-state-machines-to-realize-control>¶</a></h3><p>This pass performs a bottom-up traversal of the control program and does the following:</p><ol><li>For each control statement such as &ldquo;calyx.seq&rdquo;, create a new GroupOp to contain all
the structure to realize the schedule.</li><li>Implement the schedule by setting the constituent groups&rsquo; GoOp and DoneOp.</li><li>Replace the control statement in the control program with the corresponding
compilation group.</li></ol><h3 id=-calyx-gicm-lift-group-invariant-operations-to-wire-scope><code>-calyx-gicm</code>: Lift group-invariant operations to wire-scope.&nbsp;<a class=headline-hash href=#-calyx-gicm-lift-group-invariant-operations-to-wire-scope>¶</a></h3><p>This pass performs GICM (group-invariant code motion) of operations which are
deemed to be invariant of the group in which they are placed. In practice,
this amounts to anything which is not a <code>calyx.group_done/assign/group_go</code>
operation. GICM&rsquo;d operations are lifted to wire-scope.</p><p>After GICM, a Calyx component has the following properties:</p><ul><li>No values are being defined within groups (excluding <code>calyx.group_go</code>).
As such, groups will only contain group-level assignments
(calyx.assign/group_done).</li><li>Any value referenced by operations within the group may safely be
referenced by other groups, or operations in wire scope.</li><li>A group does not define anything structural; it exclusively describes
wiring between existing structures.</li></ul><h3 id=-calyx-go-insertion-insert-go-signals-into-the-guards-of-a-groups-non-hole-assignments><code>-calyx-go-insertion</code>: Insert go signals into the guards of a group&rsquo;s non-hole assignments&nbsp;<a class=headline-hash href=#-calyx-go-insertion-insert-go-signals-into-the-guards-of-a-groups-non-hole-assignments>¶</a></h3><p>This pass inserts the operation &ldquo;calyx.group_go&rdquo; into the guards of all
assignments housed in the group, with the exception of the &ldquo;calyx.group_done&rdquo;
terminator. For example,</p><p>Before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>calyx<span class=p>.</span>group <span class=nf>@Group1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  calyx<span class=p>.</span>assign <span class=nv>%in</span> <span class=p>=</span> <span class=nv>%out1</span><span class=p>,</span> <span class=nv>%guard</span> <span class=err>?</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  <span class=nv>%done</span> <span class=p>=</span> calyx<span class=p>.</span>group_done <span class=nv>%out2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// The `go` assignment takes on an undefined
</span></span></span><span class=line><span class=cl><span class=c>// value until the Compile Control pass.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%undef</span> <span class=p>=</span> calyx<span class=p>.</span>undef <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>calyx<span class=p>.</span>group <span class=nf>@Group1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%go</span> <span class=p>=</span> calyx<span class=p>.</span>group_go <span class=nv>%undef</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%and</span> <span class=p>=</span> comb<span class=p>.</span>and <span class=nv>%guard</span><span class=p>,</span> <span class=nv>%go</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  calyx<span class=p>.</span>assign <span class=nv>%in</span> <span class=p>=</span> <span class=nv>%out1</span><span class=p>,</span> <span class=nv>%and</span> <span class=err>?</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%done</span> <span class=p>=</span> calyx<span class=p>.</span>group_done <span class=nv>%out2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-calyx-remove-comb-groups-removes-combinational-groups-from-a-calyx-component><code>-calyx-remove-comb-groups</code>: Removes combinational groups from a Calyx component.&nbsp;<a class=headline-hash href=#-calyx-remove-comb-groups-removes-combinational-groups-from-a-calyx-component>¶</a></h3><p>Transforms combinational groups, which have a constant done condition,
into proper groups by registering the values read from the ports of cells
used within the combinational group.</p><p>It also transforms (invoke,if,while)-with into semantically equivalent
control programs that first enable a group that calculates and registers the
ports defined by the combinational group execute the respective cond group
and then execute the control operator.</p><h2 id=example>Example&nbsp;<a class=headline-hash href=#example>¶</a></h2><pre tabindex=0><code>group comb_cond&lt;&#34;static&#34;=0&gt; {
    lt.right = 32&#39;d10;
    lt.left = 32&#39;d1;
    eq.right = r.out;
    eq.left = x.out;
    comb_cond[done] = 1&#39;d1;
}
control {
    invoke comp(left = lt.out, ..)(..) with comb_cond;
    if lt.out with comb_cond {
        ...
    }
    while eq.out with comb_cond {
        ...
    }
}
</code></pre><p>into:</p><pre tabindex=0><code>group comb_cond&lt;&#34;static&#34;=1&gt; {
    lt.right = 32&#39;d10;
    lt.left = 32&#39;d1;
    eq.right = r.out;
    eq.left = x.out;
    lt_reg.in = lt.out
    lt_reg.write_en = 1&#39;d1;
    eq_reg.in = eq.out;
    eq_reg.write_en = 1&#39;d1;
    comb_cond[done] = lt_reg.done &amp; eq_reg.done ? 1&#39;d1;
}
control {
    seq {
      comb_cond;
      invoke comp(left = lt_reg.out, ..)(..);
    }
    seq {
      comb_cond;
      if lt_reg.out {
          ...
      }
    }
    seq {
      comb_cond;
      while eq_reg.out {
          ...
          comb_cond;
      }
    }
}
</code></pre><h3 id=-calyx-remove-groups-inlines-the-groups-in-a-calyx-component><code>-calyx-remove-groups</code>: Inlines the groups in a Calyx component.&nbsp;<a class=headline-hash href=#-calyx-remove-groups-inlines-the-groups-in-a-calyx-component>¶</a></h3><p>This pass removes the Group interface from the Calyx program, and inlines all
assignments. This is done in the following manner:</p><ol><li>Assign values to the &lsquo;done&rsquo; signal of the component, corresponding with the
top-level control group&rsquo;s DoneOp. Add the &lsquo;go&rsquo; signal of the component to
all assignments.</li><li>TODO(Calyx): If there are multiple writes to a signal, replace the reads
with the disjunction.</li><li>Remove all groups.</li></ol><h3 id=-calyx-reset-insertion-connect-component-reset-to-sub-component-reset-for-applicable-components><code>-calyx-reset-insertion</code>: Connect component reset to sub-component reset for applicable components.&nbsp;<a class=headline-hash href=#-calyx-reset-insertion-connect-component-reset-to-sub-component-reset-for-applicable-components>¶</a></h3><h2 id=esi-dialect-passes>ESI Dialect Passes&nbsp;<a class=headline-hash href=#esi-dialect-passes>¶</a></h2><h3 id=-esi-clean-metadata-clean-up-esi-service-metadata><code>-esi-clean-metadata</code>: Clean up ESI service metadata&nbsp;<a class=headline-hash href=#-esi-clean-metadata-clean-up-esi-service-metadata>¶</a></h3><h3 id=-esi-connect-services-connect-up-esi-service-requests-to-service-providers><code>-esi-connect-services</code>: Connect up ESI service requests to service providers&nbsp;<a class=headline-hash href=#-esi-connect-services-connect-up-esi-service-requests-to-service-providers>¶</a></h3><h3 id=-esi-emit-collateral-emit-all-the-neccessary-collateral><code>-esi-emit-collateral</code>: Emit all the neccessary collateral&nbsp;<a class=headline-hash href=#-esi-emit-collateral-emit-all-the-neccessary-collateral>¶</a></h3><h4 id=options-11>Options&nbsp;<a class=headline-hash href=#options-11>¶</a></h4><pre tabindex=0><code>-schema-file : File to output capnp schema into
-tops        : List of top modules to export Tcl for
</code></pre><h3 id=-esi-emit-cpp-api-add-c-cosimulation-api-to-the-module><code>-esi-emit-cpp-api</code>: Add C++ cosimulation API to the module&nbsp;<a class=headline-hash href=#-esi-emit-cpp-api-add-c-cosimulation-api-to-the-module>¶</a></h3><h4 id=options-12>Options&nbsp;<a class=headline-hash href=#options-12>¶</a></h4><pre tabindex=0><code>-output-file : File to output C++ API into
-to-stderr   : If true, will emit the generated API to stderr
</code></pre><h3 id=-lower-esi-ports-lower-esi-input-andor-output-ports><code>-lower-esi-ports</code>: Lower ESI input and/or output ports.&nbsp;<a class=headline-hash href=#-lower-esi-ports-lower-esi-input-andor-output-ports>¶</a></h3><h3 id=-lower-esi-to-hw-lower-esi-to-hw-where-possible-and-sv-elsewhere><code>-lower-esi-to-hw</code>: Lower ESI to HW where possible and SV elsewhere.&nbsp;<a class=headline-hash href=#-lower-esi-to-hw-lower-esi-to-hw-where-possible-and-sv-elsewhere>¶</a></h3><h3 id=-lower-esi-to-physical-lower-esi-abstract-ops-to-esi-physical-ops><code>-lower-esi-to-physical</code>: Lower ESI abstract Ops to ESI physical ops.&nbsp;<a class=headline-hash href=#-lower-esi-to-physical-lower-esi-abstract-ops-to-esi-physical-ops>¶</a></h3><h3 id=-lower-esi-types-lower-esi-high-level-types><code>-lower-esi-types</code>: Lower ESI high level types.&nbsp;<a class=headline-hash href=#-lower-esi-types-lower-esi-high-level-types>¶</a></h3><h2 id=firrtl-dialect-passes>FIRRTL Dialect Passes&nbsp;<a class=headline-hash href=#firrtl-dialect-passes>¶</a></h2><h3 id=-firrtl-add-seqmem-ports-add-extra-ports-to-memory-modules><code>-firrtl-add-seqmem-ports</code>: Add extra ports to memory modules&nbsp;<a class=headline-hash href=#-firrtl-add-seqmem-ports-add-extra-ports-to-memory-modules>¶</a></h3><p>This pass looks for <code>AddSeqMemPortAnnotation</code> annotations and adds extra
ports to memories. It will emit metadata based if the
<code>AddSeqMemPortsFileAnnotation</code> annotation is specified.</p><p>This pass requires that FIRRTL MemOps have been lowered to modules to add
the extra ports.</p><h4 id=statistics-4>Statistics&nbsp;<a class=headline-hash href=#statistics-4>¶</a></h4><pre tabindex=0><code>num-added-ports : Number of extra ports added
</code></pre><h3 id=-firrtl-blackbox-reader-load-source-files-for-black-boxes-into-the-ir><code>-firrtl-blackbox-reader</code>: Load source files for black boxes into the IR&nbsp;<a class=headline-hash href=#-firrtl-blackbox-reader-load-source-files-for-black-boxes-into-the-ir>¶</a></h3><p>This pass reads the Verilog source files for black boxes and adds them as
<code>sv.verbatim.file</code> operations into the IR. Later passes can then write
these files back to disk to ensure that they can be accessed by other tools
down the line in a well-known location. Supports inline and path
annotations for black box source files.</p><p>The supported <code>firrtl.circuit</code> annotations are:</p><ul><li><code>{class = "firrtl.transforms.BlackBoxTargetDirAnno", targetDir = "..."}</code>
Overrides the target directory into which black box source files are
emitted.</li><li><code>{class = "firrtl.transforms.BlackBoxResourceFileNameAnno", resourceFileName = "xyz.f"}</code>
Specifies the output file name for the list of black box source files that
is generated as a collateral of the pass.</li></ul><p>The supported <code>firrtl.extmodule</code> annotations are:</p><ul><li><pre tabindex=0><code>{
  class = &#34;firrtl.transforms.BlackBoxInlineAnno&#34;,
  name = &#34;myfile.v&#34;,
  text = &#34;...&#34;
}
</code></pre>Specifies the black box source code (<code>text</code>) inline. Generates a file with
the given <code>name</code> in the target directory.</li><li><pre tabindex=0><code>{
  class = &#34;firrtl.transforms.BlackBoxPathAnno&#34;,
  path = &#34;myfile.v&#34;
}
</code></pre>Specifies the file <code>path</code> as source code for the module. Copies the file
to the target directory.</li></ul><h4 id=options-13>Options&nbsp;<a class=headline-hash href=#options-13>¶</a></h4><pre tabindex=0><code>-input-prefix : Prefix for input paths in black box annotations. This should be the directory where the input file was located, to allow for annotations relative to the input file.
</code></pre><h3 id=-firrtl-check-comb-cycles-check-combinational-cycles-and-emit-errors><code>-firrtl-check-comb-cycles</code>: Check combinational cycles and emit errors&nbsp;<a class=headline-hash href=#-firrtl-check-comb-cycles-check-combinational-cycles-and-emit-errors>¶</a></h3><p>This pass checks combinational cycles in the IR and emit errors.</p><h4 id=options-14>Options&nbsp;<a class=headline-hash href=#options-14>¶</a></h4><pre tabindex=0><code>-print-simple-cycle : Print a simple cycle instead of printing all operations in SCC
</code></pre><h3 id=-firrtl-check-comb-loops-check-combinational-cycles-and-emit-errors><code>-firrtl-check-comb-loops</code>: Check combinational cycles and emit errors&nbsp;<a class=headline-hash href=#-firrtl-check-comb-loops-check-combinational-cycles-and-emit-errors>¶</a></h3><p>This pass checks combinational cycles in the IR and emit errors.</p><h3 id=-firrtl-dedup-deduplicate-modules-which-are-structurally-equivalent><code>-firrtl-dedup</code>: Deduplicate modules which are structurally equivalent&nbsp;<a class=headline-hash href=#-firrtl-dedup-deduplicate-modules-which-are-structurally-equivalent>¶</a></h3><p>This pass detects modules which are structurally equivalent and removes the
duplicate module by replacing all instances of one with the other.
Structural equivalence ignores the naming of operations and fields in
bundles, and any annotations. Deduplicating a module may cause the result
type of instances to change if the field names of a bundle type change. To
handle this, the pass will update any bulk-connections so that the correct
fields are legally connected. Deduplicated modules will have their
annotations merged, which tends to create many non-local annotations.</p><h4 id=statistics-5>Statistics&nbsp;<a class=headline-hash href=#statistics-5>¶</a></h4><pre tabindex=0><code>num-erased-modules : Number of modules which were erased by deduplication
</code></pre><h3 id=-firrtl-dft-wires-test-enables-to-clock-gates-for-dft-infrastructure><code>-firrtl-dft</code>: Wires test enables to clock gates for DFT infrastructure&nbsp;<a class=headline-hash href=#-firrtl-dft-wires-test-enables-to-clock-gates-for-dft-infrastructure>¶</a></h3><p>This pass will take a 1-bit signal targeted by
<code>DFTTestModeEnableAnnotation</code> and wires it to the <code>test_en</code> port of every
module named <code>EICG_wrapper</code>. This will create ports in any intermediate
module on the path from the signal to the <code>EICG_wrapper</code> modules. This
pass is used to enable the &ldquo;Design For Testing&rdquo; style of design when the
intermediate modules were not originally built with DFT in mind.</p><h3 id=-firrtl-drop-const-drop-const-modifier-from-types><code>-firrtl-drop-const</code>: Drop &lsquo;const&rsquo; modifier from types&nbsp;<a class=headline-hash href=#-firrtl-drop-const-drop-const-modifier-from-types>¶</a></h3><p>This pass drops the &lsquo;const&rsquo; modifier from all types and removes all
const-cast ops.</p><p>This simplifies downstream passes and folds so that they do not need to
take &lsquo;const&rsquo; into account.</p><h3 id=-firrtl-drop-names-drop-interesting-names><code>-firrtl-drop-names</code>: Drop interesting names&nbsp;<a class=headline-hash href=#-firrtl-drop-names-drop-interesting-names>¶</a></h3><p>This pass changes names of namable ops to droppable so that we can disable
full name preservation. For example,
before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> firrtl<span class=p>.</span>node interesting_name <span class=nv>%input</span>
</span></span></code></pre></div><p>after:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> firrtl<span class=p>.</span>node droppable_name <span class=nv>%input</span>
</span></span></code></pre></div><h4 id=options-15>Options&nbsp;<a class=headline-hash href=#options-15>¶</a></h4><pre tabindex=0><code>-preserve-values : specify the values which can be optimized away
</code></pre><h4 id=statistics-6>Statistics&nbsp;<a class=headline-hash href=#statistics-6>¶</a></h4><pre tabindex=0><code>num-names-converted : Number of interesting names made droppable
</code></pre><h3 id=-firrtl-emit-metadata-emit-metadata-of-the-firrtl-modules><code>-firrtl-emit-metadata</code>: Emit metadata of the FIRRTL modules&nbsp;<a class=headline-hash href=#-firrtl-emit-metadata-emit-metadata-of-the-firrtl-modules>¶</a></h3><p>This pass handles the emission of several different kinds of metadata.</p><h4 id=options-16>Options&nbsp;<a class=headline-hash href=#options-16>¶</a></h4><pre tabindex=0><code>-repl-seq-mem         : Lower the seq mem for macro replacement and emit relevant metadata
-repl-seq-mem-circuit : Circuit root for seq mem metadata
-repl-seq-mem-file    : File to which emit seq meme metadata
</code></pre><h3 id=-firrtl-emit-omir-emit-omir-annotations><code>-firrtl-emit-omir</code>: Emit OMIR annotations&nbsp;<a class=headline-hash href=#-firrtl-emit-omir-emit-omir-annotations>¶</a></h3><p>This pass gathers the <code>OMIRAnnotation</code>s in the design, updates the contained
targets with the trackers that were scattered throughout the design upon
reading the OMIR, and serializes the resulting data into a JSON file.</p><h4 id=options-17>Options&nbsp;<a class=headline-hash href=#options-17>¶</a></h4><pre tabindex=0><code>-file : Output file for the JSON-serialized OMIR data
</code></pre><h3 id=-firrtl-expand-whens-remove-all-when-conditional-blocks><code>-firrtl-expand-whens</code>: Remove all when conditional blocks.&nbsp;<a class=headline-hash href=#-firrtl-expand-whens-remove-all-when-conditional-blocks>¶</a></h3><p>This pass will:</p><ol><li>Resolve last connect semantics.</li><li>Remove all when operations.</li></ol><p>When a wire has multiple connections, only the final connection is used,
all previous connections are overwritten. When there is a conditional
connect, the previous connect is only overwritten when the condition
holds:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>w &lt;= a
when c :
  w &lt;= b

; Equivalent to:
w &lt;= mux(c, b, a)
</code></pre><p>This pass requires that all connects are expanded.</p><h3 id=-firrtl-extract-instances-move-annotated-instances-upwards-in-the-module-hierarchy><code>-firrtl-extract-instances</code>: Move annotated instances upwards in the module hierarchy&nbsp;<a class=headline-hash href=#-firrtl-extract-instances-move-annotated-instances-upwards-in-the-module-hierarchy>¶</a></h3><p>This pass takes instances in the design annotated with one out of a
particular set of annotations and pulls them upwards to a location further
up in the module hierarchy.</p><p>The annotations that control the behaviour of this pass are:</p><ul><li><code>MarkDUTAnnotation</code></li><li><code>ExtractBlackBoxAnnotation</code></li><li><code>ExtractClockGatesFileAnnotation</code></li></ul><h3 id=-firrtl-finalize-ir-perform-final-ir-mutations-after-exportverilog><code>-firrtl-finalize-ir</code>: Perform final IR mutations after ExportVerilog&nbsp;<a class=headline-hash href=#-firrtl-finalize-ir-perform-final-ir-mutations-after-exportverilog>¶</a></h3><p>This pass finalizes the IR after it has been exported with ExportVerilog,
and before firtool emits the final IR. This includes mutations like dropping
verbatim ops that represent sideband files and are not required in the IR.</p><h3 id=-firrtl-flatten-memory-flatten-aggregate-memory-data-to-a-uint><code>-firrtl-flatten-memory</code>: Flatten aggregate memory data to a UInt&nbsp;<a class=headline-hash href=#-firrtl-flatten-memory-flatten-aggregate-memory-data-to-a-uint>¶</a></h3><p>This pass flattens the aggregate data of memory into a UInt, and inserts
appropriate bitcasts to access the data.</p><h4 id=statistics-7>Statistics&nbsp;<a class=headline-hash href=#statistics-7>¶</a></h4><pre tabindex=0><code>num-flatten-mems : Number of memories flattened
</code></pre><h3 id=-firrtl-grand-central-remove-grand-central-annotations><code>-firrtl-grand-central</code>: Remove Grand Central Annotations&nbsp;<a class=headline-hash href=#-firrtl-grand-central-remove-grand-central-annotations>¶</a></h3><p>Processes annotations associated with SiFive&rsquo;s Grand Central utility.</p><h4 id=options-18>Options&nbsp;<a class=headline-hash href=#options-18>¶</a></h4><pre tabindex=0><code>-instantiate-companion-only : Instantiate the companion without a bind and drop the interface
</code></pre><h4 id=statistics-8>Statistics&nbsp;<a class=headline-hash href=#statistics-8>¶</a></h4><pre tabindex=0><code>num-views-created       : Number of top-level SystemVerilog interfaces that were created
num-interfaces-created  : Number of SystemVerilog interfaces that were created
num-xmrs-created        : Number of SystemVerilog XMRs added
num-annotations-removed : Number of annotations removed
</code></pre><h3 id=-firrtl-imconstprop-intermodule-constant-propagation-and-dead-code-elimination><code>-firrtl-imconstprop</code>: Intermodule constant propagation and dead code elimination&nbsp;<a class=headline-hash href=#-firrtl-imconstprop-intermodule-constant-propagation-and-dead-code-elimination>¶</a></h3><p>Use optimistic constant propagation to delete ports and unreachable IR.</p><h4 id=statistics-9>Statistics&nbsp;<a class=headline-hash href=#statistics-9>¶</a></h4><pre tabindex=0><code>num-folded-op : Number of operations folded
num-erased-op : Number of operations erased
</code></pre><h3 id=-firrtl-imdeadcodeelim-intermodule-dead-code-elimination><code>-firrtl-imdeadcodeelim</code>: Intermodule dead code elimination&nbsp;<a class=headline-hash href=#-firrtl-imdeadcodeelim-intermodule-dead-code-elimination>¶</a></h3><p>This pass performs inter-module liveness analysis and deletes dead code
aggressively. A value is considered as alive if it is connected to a port
of public modules or a value with a symbol. We first populate alive values
into a set, and then propagate the liveness by looking at their dataflow.</p><h4 id=statistics-10>Statistics&nbsp;<a class=headline-hash href=#statistics-10>¶</a></h4><pre tabindex=0><code>num-erased-ops     : Number of operations erased
num-erased-modules : Number of modules erased
num-removed-ports  : Number of ports erased
</code></pre><h3 id=-firrtl-infer-resets-infer-reset-synchronicity-and-add-implicit-resets><code>-firrtl-infer-resets</code>: Infer reset synchronicity and add implicit resets&nbsp;<a class=headline-hash href=#-firrtl-infer-resets-infer-reset-synchronicity-and-add-implicit-resets>¶</a></h3><p>This pass infers whether resets are synchronous or asynchronous, and extends
reset-less registers with an asynchronous reset based on the following
annotations:</p><ul><li><code>sifive.enterprise.firrtl.FullAsyncResetAnnotation</code></li><li><code>sifive.enterprise.firrtl.IgnoreFullAsyncResetAnnotation</code></li></ul><h3 id=-firrtl-infer-rw-infer-the-read-write-memory-port><code>-firrtl-infer-rw</code>: Infer the read-write memory port&nbsp;<a class=headline-hash href=#-firrtl-infer-rw-infer-the-read-write-memory-port>¶</a></h3><p>This pass merges the read and write ports of a memory, using a simple
module-scoped heuristic. The heuristic checks if the read and write enable
conditions are mutually exclusive.
The heuristic tries to break up the read enable and write enable logic into an
<code>AND</code> expression tree. It then compares the read and write <code>AND</code> terms,
looking for a situation where the read/write is the complement of the write/read.</p><h4 id=statistics-11>Statistics&nbsp;<a class=headline-hash href=#statistics-11>¶</a></h4><pre tabindex=0><code>num-rw-port-mems-inferred : Number of memories inferred to use RW port
</code></pre><h3 id=-firrtl-infer-widths-infer-the-width-of-types><code>-firrtl-infer-widths</code>: Infer the width of types&nbsp;<a class=headline-hash href=#-firrtl-infer-widths-infer-the-width-of-types>¶</a></h3><p>This pass infers the widths of all types throughout a FIRRTL module, and
emits diagnostics for types that could not be inferred.</p><h3 id=-firrtl-inject-dut-hier-add-a-level-of-hierarchy-outside-the-dut><code>-firrtl-inject-dut-hier</code>: Add a level of hierarchy outside the DUT&nbsp;<a class=headline-hash href=#-firrtl-inject-dut-hier-add-a-level-of-hierarchy-outside-the-dut>¶</a></h3><p>This pass takes the DUT (as indicated by the presence of a
MarkDUTAnnotation) and moves all the contents of it into a new module
insided the DUT named by an InjectDUTHierarchyAnnotation. This pass is
intended to be used in conjunction with passes that pull things out of the
DUT, e.g., SRAM extraction, to give the extracted modules a new home that is
still inside the original DUT.</p><h3 id=-firrtl-inliner-performs-inlining-flattening-and-dead-module-elimination><code>-firrtl-inliner</code>: Performs inlining, flattening, and dead module elimination&nbsp;<a class=headline-hash href=#-firrtl-inliner-performs-inlining-flattening-and-dead-module-elimination>¶</a></h3><p>This inliner pass will inline any instance of module marked as inline, and
recursively inline all instances inside of a module marked with flatten.
This pass performs renaming of every entity with a name that is inlined by
prefixing it with the instance name. This pass also will remove any module
which is not reachable from the top level module.</p><p>The inline and flatten annotation attributes are attached to module
definitions, and they are:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;firrtl.passes.InlineAnnotation&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;firrtl.transforms.FlattenAnnotation&#34;</span><span class=p>}</span>
</span></span></code></pre></div><h3 id=-firrtl-inner-symbol-dce-eliminate-dead-inner-symbols><code>-firrtl-inner-symbol-dce</code>: Eliminate dead inner symbols&nbsp;<a class=headline-hash href=#-firrtl-inner-symbol-dce-eliminate-dead-inner-symbols>¶</a></h3><p>This pass deletes all inner symbols which have no uses. This is necessary to
unblock optimizations and removal of the operations which have these unused
inner symbols.</p><h4 id=statistics-12>Statistics&nbsp;<a class=headline-hash href=#statistics-12>¶</a></h4><pre tabindex=0><code>num-inner-refs-found  : Number of inner-refs found
num-inner-sym-found   : Number of inner symbols found
num-inner-sym-removed : Number of inner symbols removed
</code></pre><h3 id=-firrtl-lower-annotations-lower-firrtl-annotations-to-usable-entities><code>-firrtl-lower-annotations</code>: Lower FIRRTL annotations to usable entities&nbsp;<a class=headline-hash href=#-firrtl-lower-annotations-lower-firrtl-annotations-to-usable-entities>¶</a></h3><p>Lower FIRRTL annotations to usable forms. FIRRTL annotations are a big bag
of semi-structured, irregular JSON. This pass normalizes all supported
annotations and annotation paths.</p><h4 id=options-19>Options&nbsp;<a class=headline-hash href=#options-19>¶</a></h4><pre tabindex=0><code>-disable-annotation-classless : Ignore classless annotations.
-disable-annotation-unknown   : Ignore unknown annotations.
-no-ref-type-ports            : Create normal ports, not ref type ports.
</code></pre><h4 id=statistics-13>Statistics&nbsp;<a class=headline-hash href=#statistics-13>¶</a></h4><pre tabindex=0><code>num-raw-annos       : Number of raw annotations on circuit
num-added-annos     : Number of additional annotations
num-annos           : Total number of annotations processed
num-unhandled-annos : Number of unhandled annotations
num-reused-hierpath : Number of reused HierPathOp&#39;s
</code></pre><h3 id=-firrtl-lower-chirrtl-infer-the-memory-ports-of-seqmem-and-combmem><code>-firrtl-lower-chirrtl</code>: Infer the memory ports of SeqMem and CombMem&nbsp;<a class=headline-hash href=#-firrtl-lower-chirrtl-infer-the-memory-ports-of-seqmem-and-combmem>¶</a></h3><p>This pass finds the CHIRRTL behavioral memories and their ports, and
transforms them into standard FIRRTL memory operations. For each
<code>seqmem</code> or <code>combmem</code>, a new memory is created. For every <code>memoryport</code>
operation using a CHIRRTL memory, a memory port is defined on the
new standard memory.</p><p>The direction or kind of the port is inferred from how each of the memory
ports is used in the IR. If a memory port is only written to, it becomes
a <code>Write</code> port. If a memory port is only read from, it become a <code>Read</code>
port. If it is used both ways, it becomes a <code>ReadWrite</code> port.</p><p><code>Write</code>, <code>ReadWrite</code> and combinational <code>Read</code> ports are disabled by
default, but then enabled when the CHIRRTL memory port is declared.
Sequential <code>Read</code> ports have more complicated enable inference:</p><ol><li>If a wire or register is used as the index of the memory port, then
the memory is enabled whenever a non-invalid value is driven to the
address.</li><li>If a node is used as the index of the memory port, then the memory is
enabled at the declaration of the node.</li><li>In all other cases, the memory is never enabled.</li></ol><p>In the first two cases, they can easily produce a situation where we try
to enable the memory before it is even declared. This produces a
compilation error.</p><h4 id=statistics-14>Statistics&nbsp;<a class=headline-hash href=#statistics-14>¶</a></h4><pre tabindex=0><code>num-created-mems  : Number of memories created
num-lowered-mems  : Number of memories lowered
num-portless-mems : Number of memories dropped as having no valid ports
</code></pre><h3 id=-firrtl-lower-intrinsics-lower-intrinsics><code>-firrtl-lower-intrinsics</code>: Lower intrinsics&nbsp;<a class=headline-hash href=#-firrtl-lower-intrinsics-lower-intrinsics>¶</a></h3><p>This pass lowers intrinsics encoded as extmodule with annotation and
intmodule to their implementation or op.</p><h3 id=-firrtl-lower-matches-remove-all-matchs-conditional-blocks><code>-firrtl-lower-matches</code>: Remove all matchs conditional blocks&nbsp;<a class=headline-hash href=#-firrtl-lower-matches-remove-all-matchs-conditional-blocks>¶</a></h3><p>Lowers FIRRTL match statements in to when statements, which can later be
lowered with ExpandWhens.</p><h3 id=-firrtl-lower-memory-lower-memories-to-generated-modules><code>-firrtl-lower-memory</code>: Lower memories to generated modules&nbsp;<a class=headline-hash href=#-firrtl-lower-memory-lower-memories-to-generated-modules>¶</a></h3><p>This pass lowers FIRRTL memory operations to generated modules.</p><h4 id=statistics-15>Statistics&nbsp;<a class=headline-hash href=#statistics-15>¶</a></h4><pre tabindex=0><code>num-created-mem-modules : Number of modules created
num-lowered-mems        : Number of memories lowered
</code></pre><h3 id=-firrtl-lower-open-aggs-lower-open-aggregates-by-splitting-out-non-hardware-elements><code>-firrtl-lower-open-aggs</code>: Lower &lsquo;Open&rsquo; aggregates by splitting out non-hardware elements&nbsp;<a class=headline-hash href=#-firrtl-lower-open-aggs-lower-open-aggregates-by-splitting-out-non-hardware-elements>¶</a></h3><p>This pass lowers aggregates of the more open varieties into their equivalents
using only hardware types, by pulling out non-hardware to other locations.</p><h3 id=-firrtl-lower-types-lower-firrtl-types-to-ground-types><code>-firrtl-lower-types</code>: Lower FIRRTL types to ground types&nbsp;<a class=headline-hash href=#-firrtl-lower-types-lower-firrtl-types-to-ground-types>¶</a></h3><p>Lower aggregate FIRRTL types to ground types. Memories, ports, wires, etc
are split apart by elements of aggregate types. The only aggregate types
which exist after this pass are memory ports, though memory data types are
split.</p><p>Connect and expansion and canonicalization happen in this pass.</p><h4 id=options-20>Options&nbsp;<a class=headline-hash href=#options-20>¶</a></h4><pre tabindex=0><code>-flatten-mem        : Concat all elements of the aggregate data into a single element.
-preserve-aggregate : Specify aggregate preservation mode
-preserve-memories  : Specify memory preservation mode
</code></pre><h3 id=-firrtl-lower-xmr-lower-ref-ports-to-xmr><code>-firrtl-lower-xmr</code>: Lower ref ports to XMR&nbsp;<a class=headline-hash href=#-firrtl-lower-xmr-lower-ref-ports-to-xmr>¶</a></h3><p>This pass lowers RefType ops and ports to verbatim encoded XMRs.</p><h3 id=-firrtl-mem-to-reg-of-vec-convert-combinational-memories-to-a-vector-of-registers><code>-firrtl-mem-to-reg-of-vec</code>: Convert combinational memories to a vector of registers&nbsp;<a class=headline-hash href=#-firrtl-mem-to-reg-of-vec-convert-combinational-memories-to-a-vector-of-registers>¶</a></h3><p>This pass generates the logic to implement a memory using Registers.</p><h4 id=options-21>Options&nbsp;<a class=headline-hash href=#options-21>¶</a></h4><pre tabindex=0><code>-repl-seq-mem           : Prepare seq mems for macro replacement
-ignore-read-enable-mem : ignore the read enable signal, instead of assigning X on read disable
</code></pre><h4 id=statistics-16>Statistics&nbsp;<a class=headline-hash href=#statistics-16>¶</a></h4><pre tabindex=0><code>num-converted-mems : Number of memories converted to registers
</code></pre><h3 id=-firrtl-prefix-modules-prefixes-names-of-modules-and-mems-in-a-hierarchy><code>-firrtl-prefix-modules</code>: Prefixes names of modules and mems in a hierarchy&nbsp;<a class=headline-hash href=#-firrtl-prefix-modules-prefixes-names-of-modules-and-mems-in-a-hierarchy>¶</a></h3><p>This pass looks for modules annotated with the
<code>NestedPrefixModulesAnnotation</code> and prefixes the names of all modules
instantiated underneath it. If <code>inclusive</code> is true, it includes the target
module in the renaming. If <code>inclusive</code> is false, it will only rename
modules instantiated underneath the target module. If a module is required
to have two different prefixes, it will be cloned.</p><p>The supported annotation is:</p><pre tabindex=0><code>  {
    class = &#34;sifive.enterprise.firrtl.NestedPrefixModulesAnnotation&#34;,
    prefix = &#34;MyPrefix_&#34;,
    inclusive = true
  }
</code></pre><h3 id=-firrtl-print-field-source-print-field-source-information><code>-firrtl-print-field-source</code>: Print field source information.&nbsp;<a class=headline-hash href=#-firrtl-print-field-source-print-field-source-information>¶</a></h3><h3 id=-firrtl-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy><code>-firrtl-print-instance-graph</code>: Print a DOT graph of the module hierarchy.&nbsp;<a class=headline-hash href=#-firrtl-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy>¶</a></h3><h3 id=-firrtl-print-nla-table-print-the-nla-table><code>-firrtl-print-nla-table</code>: Print the NLA Table.&nbsp;<a class=headline-hash href=#-firrtl-print-nla-table-print-the-nla-table>¶</a></h3><h3 id=-firrtl-randomize-register-init-randomize-register-initialization><code>-firrtl-randomize-register-init</code>: Randomize register initialization.&nbsp;<a class=headline-hash href=#-firrtl-randomize-register-init-randomize-register-initialization>¶</a></h3><p>This pass eagerly creates large vectors of randomized bits for initializing
registers, and marks each register with attributes indicating which bits to
read. If the registers survive until LowerToHW, their initialization logic
will pick up the correct bits.</p><p>This ensures a stable initialization, so registers should always see the
same initial value for the same seed, regardless of optimization levels.</p><h3 id=-firrtl-register-optimizer-optimizer-registers><code>-firrtl-register-optimizer</code>: Optimizer Registers&nbsp;<a class=headline-hash href=#-firrtl-register-optimizer-optimizer-registers>¶</a></h3><p>This pass applies classic FIRRTL register optimizations. These
optimizations are isolated to this pass as they can change the visible
behavior of the register, especially before reset.</p><h3 id=-firrtl-remove-unused-ports-remove-unused-ports><code>-firrtl-remove-unused-ports</code>: Remove unused ports&nbsp;<a class=headline-hash href=#-firrtl-remove-unused-ports-remove-unused-ports>¶</a></h3><p>This pass removes unused ports without annotations or symbols. Implementation
wise, this pass iterates over the instance graph in a topological order from
leaves to the top so that we can remove unused ports optimally.</p><h4 id=statistics-17>Statistics&nbsp;<a class=headline-hash href=#statistics-17>¶</a></h4><pre tabindex=0><code>num-removed-ports : Number of ports erased
</code></pre><h3 id=-firrtl-resolve-traces-write-out-traceannotations-to-an-output-annotation-file><code>-firrtl-resolve-traces</code>: Write out TraceAnnotations to an output annotation file&nbsp;<a class=headline-hash href=#-firrtl-resolve-traces-write-out-traceannotations-to-an-output-annotation-file>¶</a></h3><p>This pass implements Chisel&rsquo;s Trace API. It collects all TraceAnnotations
that exist in the circuit, updates them with information about the final
target in a design, and writes these to an output annotation file. This
exists for Chisel users to build tooling around them that needs to query the
final output name/path of some component in a Chisel circuit.</p><p>Note: this pass and API are expected to be eventually replaced via APIs and
language bindings that enable users to directly query the MLIR.</p><h4 id=options-22>Options&nbsp;<a class=headline-hash href=#options-22>¶</a></h4><pre tabindex=0><code>-file : Output file for the JSON-serialized Trace Annotations
</code></pre><h3 id=-firrtl-sfc-compat-perform-sfc-compatibility-fixes><code>-firrtl-sfc-compat</code>: Perform SFC Compatibility fixes&nbsp;<a class=headline-hash href=#-firrtl-sfc-compat-perform-sfc-compatibility-fixes>¶</a></h3><h3 id=-firrtl-vb-to-bv-transform-vector-of-bundles-to-bundle-of-vectors><code>-firrtl-vb-to-bv</code>: Transform vector-of-bundles to bundle-of-vectors&nbsp;<a class=headline-hash href=#-firrtl-vb-to-bv-transform-vector-of-bundles-to-bundle-of-vectors>¶</a></h3><p>This pass converts vectors containing bundles, into bundles containing
vectors.</p><h3 id=-merge-connections-merge-field-level-connections-into-full-bundle-connections><code>-merge-connections</code>: Merge field-level connections into full bundle connections&nbsp;<a class=headline-hash href=#-merge-connections-merge-field-level-connections-into-full-bundle-connections>¶</a></h3><h4 id=options-23>Options&nbsp;<a class=headline-hash href=#options-23>¶</a></h4><pre tabindex=0><code>-aggressive-merging : Merge connections even when source values won&#39;t be simplified.
</code></pre><h3 id=-vectorization-transform-firrtl-primitive-operations-into-vector-operations><code>-vectorization</code>: Transform firrtl primitive operations into vector operations&nbsp;<a class=headline-hash href=#-vectorization-transform-firrtl-primitive-operations-into-vector-operations>¶</a></h3><h2 id=fsm-dialect-passes>FSM Dialect Passes&nbsp;<a class=headline-hash href=#fsm-dialect-passes>¶</a></h2><h3 id=-fsm-print-graph-print-a-dot-graph-of-the-module-hierarchy><code>-fsm-print-graph</code>: Print a DOT graph of the module hierarchy.&nbsp;<a class=headline-hash href=#-fsm-print-graph-print-a-dot-graph-of-the-module-hierarchy>¶</a></h3><h2 id=handshake-dialect-passes>Handshake Dialect Passes&nbsp;<a class=headline-hash href=#handshake-dialect-passes>¶</a></h2><h3 id=-handshake-add-ids-add-an-id-to-each-operation-in-a-handshake-function><code>-handshake-add-ids</code>: Add an ID to each operation in a handshake function.&nbsp;<a class=headline-hash href=#-handshake-add-ids-add-an-id-to-each-operation-in-a-handshake-function>¶</a></h3><p>This pass adds an ID to each operation in a handshake function. This id can
be used in lowerings facilitate mapping lowered IR back to the handshake code
which it originated from. An ID is unique with respect to other operations
of the same type in the function. The tuple of the operation name and the
operation ID denotes a unique identifier for the operation within the
<code>handshake.func</code> operation.</p><h3 id=-handshake-dematerialize-forks-sinks-dematerialize-fork-and-sink-operations><code>-handshake-dematerialize-forks-sinks</code>: Dematerialize fork and sink operations.&nbsp;<a class=headline-hash href=#-handshake-dematerialize-forks-sinks-dematerialize-fork-and-sink-operations>¶</a></h3><p>This pass analyses a handshake.func operation and removes all fork and sink
operations.</p><h3 id=-handshake-insert-buffers-insert-buffers-to-break-graph-cycles><code>-handshake-insert-buffers</code>: Insert buffers to break graph cycles&nbsp;<a class=headline-hash href=#-handshake-insert-buffers-insert-buffers-to-break-graph-cycles>¶</a></h3><h4 id=options-24>Options&nbsp;<a class=headline-hash href=#options-24>¶</a></h4><pre tabindex=0><code>-strategy    : Strategy to apply. Possible values are: cycles, allFIFO, all (default)
-buffer-size : Number of slots in each buffer
</code></pre><h3 id=-handshake-legalize-memrefs-memref-legalization-and-lowering-pass><code>-handshake-legalize-memrefs</code>: Memref legalization and lowering pass.&nbsp;<a class=headline-hash href=#-handshake-legalize-memrefs-memref-legalization-and-lowering-pass>¶</a></h3><p>Lowers various memref operations to a state suitable for passing to the
StandardToHandshake lowering.</p><h3 id=-handshake-lock-functions-lock-each-function-to-only-allow-single-invocations><code>-handshake-lock-functions</code>: Lock each function to only allow single invocations.&nbsp;<a class=headline-hash href=#-handshake-lock-functions-lock-each-function-to-only-allow-single-invocations>¶</a></h3><p>This pass adds a locking mechanism to each handshake function. This mechanism
ensures that only one control token can be active in a function at each point
in time.</p><h3 id=-handshake-lower-extmem-to-hw-lowers-handshakeextmem-and-memref-inputs-to-ports><code>-handshake-lower-extmem-to-hw</code>: Lowers handshake.extmem and memref inputs to ports.&nbsp;<a class=headline-hash href=#-handshake-lower-extmem-to-hw-lowers-handshakeextmem-and-memref-inputs-to-ports>¶</a></h3><p>Lowers handshake.extmem and memref inputs to a hardware-targeting
memory accessing scheme (explicit load- and store ports on the top
level interface).</p><h4 id=options-25>Options&nbsp;<a class=headline-hash href=#options-25>¶</a></h4><pre tabindex=0><code>-wrap-esi : Create an ESI wrapper for the module. Any extmem will be served by an esi.mem.ram service
</code></pre><h3 id=-handshake-materialize-forks-sinks-materialize-fork-and-sink-operations><code>-handshake-materialize-forks-sinks</code>: Materialize fork and sink operations.&nbsp;<a class=headline-hash href=#-handshake-materialize-forks-sinks-materialize-fork-and-sink-operations>¶</a></h3><p>This pass analyses a handshake.func operation and inserts fork and sink
operations ensuring that all values have exactly one use.</p><h3 id=-handshake-op-count-count-the-number-of-operations-resources-in-a-handshake-function><code>-handshake-op-count</code>: Count the number of operations (resources) in a handshake function.&nbsp;<a class=headline-hash href=#-handshake-op-count-count-the-number-of-operations-resources-in-a-handshake-function>¶</a></h3><p>This pass analyses a handshake.func operation and prints the number of
operations (resources) used the function.</p><h3 id=-handshake-print-dot-print-dot-graph-of-a-handshake-function><code>-handshake-print-dot</code>: Print .dot graph of a handshake function.&nbsp;<a class=headline-hash href=#-handshake-print-dot-print-dot-graph-of-a-handshake-function>¶</a></h3><p>This pass analyses a handshake.func operation and prints a .dot graph of the
structure. If multiple functions are present in the IR, the top level
function will be printed, and called functions will be subgraphs within
the main graph.</p><h3 id=-handshake-remove-buffers-remove-buffers-from-handshake-functions><code>-handshake-remove-buffers</code>: Remove buffers from handshake functions.&nbsp;<a class=headline-hash href=#-handshake-remove-buffers-remove-buffers-from-handshake-functions>¶</a></h3><p>This pass analyses a handshake.func operation and removes any buffers from
the function.</p><h2 id=hw-dialect-passes>HW Dialect Passes&nbsp;<a class=headline-hash href=#hw-dialect-passes>¶</a></h2><h3 id=-hw-flatten-io-flattens-hwstructure-typed-in--and-output-ports><code>-hw-flatten-io</code>: Flattens hw::Structure typed in- and output ports.&nbsp;<a class=headline-hash href=#-hw-flatten-io-flattens-hwstructure-typed-in--and-output-ports>¶</a></h3><h4 id=options-26>Options&nbsp;<a class=headline-hash href=#options-26>¶</a></h4><pre tabindex=0><code>-recursive : Recursively flatten nested structs.
</code></pre><h3 id=-hw-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy><code>-hw-print-instance-graph</code>: Print a DOT graph of the module hierarchy.&nbsp;<a class=headline-hash href=#-hw-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy>¶</a></h3><h3 id=-hw-print-module-graph-print-a-dot-graph-of-the-hwmodules-within-a-top-level-module><code>-hw-print-module-graph</code>: Print a DOT graph of the HWModule&rsquo;s within a top-level module.&nbsp;<a class=headline-hash href=#-hw-print-module-graph-print-a-dot-graph-of-the-hwmodules-within-a-top-level-module>¶</a></h3><h4 id=options-27>Options&nbsp;<a class=headline-hash href=#options-27>¶</a></h4><pre tabindex=0><code>-verbose-edges : Print information on SSA edges (types, operand #, ...)
</code></pre><h3 id=-hw-specialize-specializes-instances-of-parametric-hwmodules><code>-hw-specialize</code>: Specializes instances of parametric hw.modules&nbsp;<a class=headline-hash href=#-hw-specialize-specializes-instances-of-parametric-hwmodules>¶</a></h3><p>Any <code>hw.instance</code> operation instantiating a parametric <code>hw.module</code> will
trigger a specialization procedure which resolves all parametric types and
values within the module based on the set of provided parameters to the
<code>hw.instance</code> operation. This specialized module is created as a new
<code>hw.module</code> and the referring <code>hw.instance</code> operation is rewritten to
instantiate the newly specialized module.</p><h2 id=llhd-dialect-passes>LLHD Dialect Passes&nbsp;<a class=headline-hash href=#llhd-dialect-passes>¶</a></h2><h3 id=-llhd-early-code-motion-move-side-effect-free-instructions-and-llhdprb-up-in-the-cfg><code>-llhd-early-code-motion</code>: Move side-effect-free instructions and llhd.prb up in the CFG&nbsp;<a class=headline-hash href=#-llhd-early-code-motion-move-side-effect-free-instructions-and-llhdprb-up-in-the-cfg>¶</a></h3><p>Moves side-effect-free instructions as far up in the CFG as possible. That
means to the earliest block where all operands are defined. Special care has
to be given to the <code>llhd.prb</code> instruction (which is the only side-effect
instruction moved by this pass) as it must stay in the same temporal region,
because otherwise it might sample an older or newer state of the signal.
This pass is designed as a preparatory pass for the Temporal Code Motion
pass to be able to move the <code>llhd.drv</code> operations in a single TR exiting
block without having to move operations defining the operands used by the
<code>llhd.drv</code>. It also enables total control flow elimination as the <code>llhd.prb</code>
instructions would not be moved by other canonicalization passes.</p><h3 id=-llhd-function-elimination-deletes-all-functions><code>-llhd-function-elimination</code>: Deletes all functions.&nbsp;<a class=headline-hash href=#-llhd-function-elimination-deletes-all-functions>¶</a></h3><p>Deletes all functions in the module. In case there is still a function
call in an entity or process, it fails.
This pass is intended as a post-inlining pass to check if all functions
could be successfully inlined and remove the inlined functions. This
is necessary because Structural LLHD does not allow functions. Fails in
the case that there is still a function call left in a <code>llhd.proc</code> or
<code>llhd.entity</code>.</p><h3 id=-llhd-memory-to-block-argument-promote-memory-to-block-arguments><code>-llhd-memory-to-block-argument</code>: Promote memory to block arguments.&nbsp;<a class=headline-hash href=#-llhd-memory-to-block-argument-promote-memory-to-block-arguments>¶</a></h3><p>Promotes memory locations allocated with <code>llhd.var</code> to block arguments. This
enables other optimizations and is required to be able to lower behavioral
LLHD to structural LLHD. This is because there are no memory model and
control flow in structural LLHD. After executing this pass, the
&ldquo;-llhd-block-argument-to-mux&rdquo; pass can be used to convert the block
arguments to multiplexers to enable more control-flow elimination.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>proc <span class=nf>@check_simple</span><span class=p>(</span><span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c5</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%cond</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%ptr</span> <span class=p>=</span> llhd<span class=p>.</span>var <span class=nv>%c5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c6</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>6</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>store <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%c6</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  br <span class=nl>^bb2
</span></span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%ld</span> <span class=p>=</span> llhd<span class=p>.</span>load <span class=nv>%ptr</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%ld</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>halt
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>is transformed to</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>proc <span class=nf>@check_simple</span><span class=p>(</span><span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c5</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%cond</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%c5</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c6</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>6</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  br <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%c6</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>halt
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-llhd-process-lowering-lowers-llhd-processes-to-entities><code>-llhd-process-lowering</code>: Lowers LLHD Processes to Entities.&nbsp;<a class=headline-hash href=#-llhd-process-lowering-lowers-llhd-processes-to-entities>¶</a></h3><p>TODO</p><h2 id=msft-dialect-passes>MSFT Dialect Passes&nbsp;<a class=headline-hash href=#msft-dialect-passes>¶</a></h2><h3 id=-lower-msft-to-hw-lower-msft-ops-to-hw-ops><code>-lower-msft-to-hw</code>: Lower MSFT ops to hw ops&nbsp;<a class=headline-hash href=#-lower-msft-to-hw-lower-msft-ops-to-hw-ops>¶</a></h3><h4 id=options-28>Options&nbsp;<a class=headline-hash href=#options-28>¶</a></h4><pre tabindex=0><code>-verilog-file : File to output Verilog into
</code></pre><h3 id=-msft-discover-appids-discover-the-appids-in-a-module-hierarchy><code>-msft-discover-appids</code>: Discover the appids in a module hierarchy&nbsp;<a class=headline-hash href=#-msft-discover-appids-discover-the-appids-in-a-module-hierarchy>¶</a></h3><h3 id=-msft-export-tcl-create-tcl-ops><code>-msft-export-tcl</code>: Create tcl ops&nbsp;<a class=headline-hash href=#-msft-export-tcl-create-tcl-ops>¶</a></h3><h4 id=options-29>Options&nbsp;<a class=headline-hash href=#options-29>¶</a></h4><pre tabindex=0><code>-tops     : List of top modules to export Tcl for
-tcl-file : File to output Tcl into
</code></pre><h3 id=-msft-lower-constructs-lower-high-level-constructs><code>-msft-lower-constructs</code>: Lower high-level constructs&nbsp;<a class=headline-hash href=#-msft-lower-constructs-lower-high-level-constructs>¶</a></h3><h3 id=-msft-lower-instances-lower-dynamic-instances><code>-msft-lower-instances</code>: Lower dynamic instances&nbsp;<a class=headline-hash href=#-msft-lower-instances-lower-dynamic-instances>¶</a></h3><h3 id=-msft-partition-move-the-entities-targeted-for-a-design-partition><code>-msft-partition</code>: Move the entities targeted for a design partition&nbsp;<a class=headline-hash href=#-msft-partition-move-the-entities-targeted-for-a-design-partition>¶</a></h3><h3 id=-msft-wire-cleanup-cleanup-unnecessary-ports-and-wires><code>-msft-wire-cleanup</code>: Cleanup unnecessary ports and wires&nbsp;<a class=headline-hash href=#-msft-wire-cleanup-cleanup-unnecessary-ports-and-wires>¶</a></h3><h2 id=pipeline-dialect-passes>Pipeline Dialect Passes&nbsp;<a class=headline-hash href=#pipeline-dialect-passes>¶</a></h2><h3 id=-pipeline-explicit-regs-makes-stage-registers-explicit><code>-pipeline-explicit-regs</code>: Makes stage registers explicit.&nbsp;<a class=headline-hash href=#-pipeline-explicit-regs-makes-stage-registers-explicit>¶</a></h3><p>Makes all stage-crossing def-use chains into explicit registers.</p><h3 id=-pipeline-schedule-linear-schedules-a-linear-pipeline><code>-pipeline-schedule-linear</code>: Schedules a linear pipeline.&nbsp;<a class=headline-hash href=#-pipeline-schedule-linear-schedules-a-linear-pipeline>¶</a></h3><p>Schedules a linear pipeline based on operator latencies.</p><h2 id=seq-dialect-passes>Seq Dialect Passes&nbsp;<a class=headline-hash href=#seq-dialect-passes>¶</a></h2><h3 id=-lower-seq-firrtl-init-to-sv-prep-the-module-with-macro-definitions-for-firrtl-registers><code>-lower-seq-firrtl-init-to-sv</code>: Prep the module with macro definitions for firrtl registers.&nbsp;<a class=headline-hash href=#-lower-seq-firrtl-init-to-sv-prep-the-module-with-macro-definitions-for-firrtl-registers>¶</a></h3><h3 id=-lower-seq-firrtl-to-sv-lower-sequential-firrtl-ops-to-sv><code>-lower-seq-firrtl-to-sv</code>: Lower sequential firrtl ops to SV.&nbsp;<a class=headline-hash href=#-lower-seq-firrtl-to-sv-lower-sequential-firrtl-ops-to-sv>¶</a></h3><h4 id=options-30>Options&nbsp;<a class=headline-hash href=#options-30>¶</a></h4><pre tabindex=0><code>-disable-reg-randomization   : Disable emission of register randomization code
-emit-separate-always-blocks : Emit assigments to registers in separate always blocks
</code></pre><h4 id=statistics-18>Statistics&nbsp;<a class=headline-hash href=#statistics-18>¶</a></h4><pre tabindex=0><code>num-subaccess-restored : Number of lhs subaccess operations restored 
</code></pre><h3 id=-lower-seq-hlmem-lowers-seqhlmem-operations><code>-lower-seq-hlmem</code>: Lowers seq.hlmem operations.&nbsp;<a class=headline-hash href=#-lower-seq-hlmem-lowers-seqhlmem-operations>¶</a></h3><h3 id=-lower-seq-to-sv-lower-sequential-ops-to-sv><code>-lower-seq-to-sv</code>: Lower sequential ops to SV.&nbsp;<a class=headline-hash href=#-lower-seq-to-sv-lower-sequential-ops-to-sv>¶</a></h3><h4 id=options-31>Options&nbsp;<a class=headline-hash href=#options-31>¶</a></h4><pre tabindex=0><code>-lower-to-always-ff : Place assignments to registers into `always_ff` blocks
</code></pre><h2 id=ssp-dialect-passes>SSP Dialect Passes&nbsp;<a class=headline-hash href=#ssp-dialect-passes>¶</a></h2><h3 id=-ssp-print-prints-all-ssp-instances-as-dot-graphs><code>-ssp-print</code>: Prints all SSP instances as DOT graphs.&nbsp;<a class=headline-hash href=#-ssp-print-prints-all-ssp-instances-as-dot-graphs>¶</a></h3><h3 id=-ssp-roundtrip-roundtrips-all-ssp-instances-via-the-scheduling-infrastructure><code>-ssp-roundtrip</code>: Roundtrips all SSP instances via the scheduling infrastructure&nbsp;<a class=headline-hash href=#-ssp-roundtrip-roundtrips-all-ssp-instances-via-the-scheduling-infrastructure>¶</a></h3><h4 id=options-32>Options&nbsp;<a class=headline-hash href=#options-32>¶</a></h4><pre tabindex=0><code>-check  : Check the problem&#39;s input constraints.
-verify : Verify the problem&#39;s solution constraints.
</code></pre><h3 id=-ssp-schedule-schedules-all-ssp-instances><code>-ssp-schedule</code>: Schedules all SSP instances.&nbsp;<a class=headline-hash href=#-ssp-schedule-schedules-all-ssp-instances>¶</a></h3><h4 id=options-33>Options&nbsp;<a class=headline-hash href=#options-33>¶</a></h4><pre tabindex=0><code>-scheduler : Scheduling algorithm to use.
-options   : Scheduler-specific options.
</code></pre><h2 id=sv-dialect-passes>SV Dialect Passes&nbsp;<a class=headline-hash href=#sv-dialect-passes>¶</a></h2><h3 id=-hw-cleanup-cleanup-transformations-for-operations-in-hwmodule-bodies><code>-hw-cleanup</code>: Cleanup transformations for operations in hw.module bodies&nbsp;<a class=headline-hash href=#-hw-cleanup-cleanup-transformations-for-operations-in-hwmodule-bodies>¶</a></h3><p>This pass merges sv.alwaysff operations with the same condition, sv.ifdef
nodes with the same condition, and perform other cleanups for the IR.
This is a good thing to run early in the HW/SV pass pipeline to expose
opportunities for other simpler passes (like canonicalize).</p><h4 id=options-34>Options&nbsp;<a class=headline-hash href=#options-34>¶</a></h4><pre tabindex=0><code>-merge-always-blocks : Allow always and always_ff blocks to be merged
</code></pre><h3 id=-hw-export-module-hierarchy-export-module-and-instance-hierarchy-information><code>-hw-export-module-hierarchy</code>: Export module and instance hierarchy information&nbsp;<a class=headline-hash href=#-hw-export-module-hierarchy-export-module-and-instance-hierarchy-information>¶</a></h3><p>This pass exports the module and instance hierarchy tree for each module
with the firrtl.moduleHierarchyFile attribute. These are lowered to
sv.verbatim ops with the output_file attribute.</p><h4 id=options-35>Options&nbsp;<a class=headline-hash href=#options-35>¶</a></h4><pre tabindex=0><code>-dir-name : Directory to emit into
</code></pre><h3 id=-hw-generator-callout-lower-generator-schema-to-external-module><code>-hw-generator-callout</code>: Lower Generator Schema to external module&nbsp;<a class=headline-hash href=#-hw-generator-callout-lower-generator-schema-to-external-module>¶</a></h3><p>This pass calls an external program for all the hw.module.generated nodes,
following the description in the hw.generator.schema node.</p><h4 id=options-36>Options&nbsp;<a class=headline-hash href=#options-36>¶</a></h4><pre tabindex=0><code>-schema-name                    : Name of the schema to process
-generator-executable           : Generator program executable with optional full path
-generator-executable-arguments : Generator program arguments separated by ;
</code></pre><h3 id=-hw-legalize-modules-eliminate-features-marked-unsupported-in-loweringoptions><code>-hw-legalize-modules</code>: Eliminate features marked unsupported in LoweringOptions&nbsp;<a class=headline-hash href=#-hw-legalize-modules-eliminate-features-marked-unsupported-in-loweringoptions>¶</a></h3><p>This pass lowers away features in the SV/Comb/HW dialects that are
unsupported by some tools, e.g. multidimensional arrays. This pass is
run relatively late in the pipeline in preparation for emission. Any
passes run after this must be aware they cannot introduce new invalid
constructs.</p><h3 id=-hw-memory-sim-implement-firrtmmem-memories-nodes-with-simulation-model><code>-hw-memory-sim</code>: Implement FIRRTMMem memories nodes with simulation model&nbsp;<a class=headline-hash href=#-hw-memory-sim-implement-firrtmmem-memories-nodes-with-simulation-model>¶</a></h3><p>This pass replaces generated module nodes of type FIRRTLMem with a model
suitable for simulation.</p><h4 id=options-37>Options&nbsp;<a class=headline-hash href=#options-37>¶</a></h4><pre tabindex=0><code>-disable-mem-randomization                                : Disable emission of memory randomization code
-disable-reg-randomization                                : Disable emission of register randomization code
-repl-seq-mem                                             : Prepare seq mems for macro replacement
-ignore-read-enable                                       : ignore the read enable signal, instead of assigning X on read disable
-add-mux-pragmas                                          : Add mux pragmas to memory reads
-add-vivado-ram-address-conflict-synthesis-bug-workaround : Add a vivado attribute to specify a ram style of an array register
</code></pre><h3 id=-hw-stub-external-modules-transform-external-hw-modules-to-empty-hw-modules><code>-hw-stub-external-modules</code>: transform external hw modules to empty hw modules&nbsp;<a class=headline-hash href=#-hw-stub-external-modules-transform-external-hw-modules-to-empty-hw-modules>¶</a></h3><p>This pass creates empty module bodies for external modules. This is
useful for linting to eliminate missing file errors.</p><h3 id=-prettify-verilog-transformations-to-improve-quality-of-exportverilog-output><code>-prettify-verilog</code>: Transformations to improve quality of ExportVerilog output&nbsp;<a class=headline-hash href=#-prettify-verilog-transformations-to-improve-quality-of-exportverilog-output>¶</a></h3><p>This pass contains elective transformations that improve the quality of
SystemVerilog generated by the ExportVerilog library. This pass is not
compulsory: things that are required for ExportVerilog to be correct
should be included as part of the ExportVerilog pass itself to make sure
it is self contained.</p><h3 id=-sv-extract-test-code-extract-simulation-only-constructs-to-modules-and-bind><code>-sv-extract-test-code</code>: Extract simulation only constructs to modules and bind&nbsp;<a class=headline-hash href=#-sv-extract-test-code-extract-simulation-only-constructs-to-modules-and-bind>¶</a></h3><p>This pass extracts cover, assume, assert operations to a module, along with
any ops feeding them only, to modules which are instantiated with a bind
statement.</p><h4 id=options-38>Options&nbsp;<a class=headline-hash href=#options-38>¶</a></h4><pre tabindex=0><code>-disable-instance-extraction : Disable extracting instances only that feed test code
-disable-module-inlining     : Disable inlining modules that only feed test code
</code></pre><h4 id=statistics-19>Statistics&nbsp;<a class=headline-hash href=#statistics-19>¶</a></h4><pre tabindex=0><code>num-ops-extracted : Number of ops extracted
num-ops-erased    : Number of ops erased
</code></pre><h3 id=-sv-trace-iverilog-add-tracing-to-an-iverilog-simulated-module><code>-sv-trace-iverilog</code>: Add tracing to an iverilog simulated module&nbsp;<a class=headline-hash href=#-sv-trace-iverilog-add-tracing-to-an-iverilog-simulated-module>¶</a></h3><p>This pass adds the necessary instrumentation to a HWModule to trigger
tracing in an iverilog simulation.</p><h4 id=options-39>Options&nbsp;<a class=headline-hash href=#options-39>¶</a></h4><pre tabindex=0><code>-top-only : If true, will only add tracing to the top-level module.
-module   : Module to trace. If not provided, will trace all modules
-dir-name : Directory to emit into
</code></pre><h2 id=systemc-dialect-passes>SystemC Dialect Passes&nbsp;<a class=headline-hash href=#systemc-dialect-passes>¶</a></h2><h3 id=-systemc-lower-instance-interop-lower-all-systemc-instance-interop-operations><code>-systemc-lower-instance-interop</code>: Lower all SystemC instance interop operations.&nbsp;<a class=headline-hash href=#-systemc-lower-instance-interop-lower-all-systemc-instance-interop-operations>¶</a></h3><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/GettingStarted/ title="Getting Started with the CIRCT Project"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Getting Started with the CIRCT Project</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/PyCDE/ title="Python CIRCT Design Entry (PyCDE)">Next - Python CIRCT Design Entry (PyCDE) <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/DCPasses/></a></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li class=active><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>