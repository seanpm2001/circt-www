<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'firrtl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/FIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'firrtl' Dialect</h1><p>This dialect defines the <code>firrtl</code> dialect, which is used to lower from Chisel
code to Verilog. For more information, see the
<a href=https://github.com/freechipsproject/firrtl>FIRRTL GitHub
page</a>.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definitions----structure>Operation Definitions &ndash; Structure</a><ul><li><a href=#firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)</a></li><li><a href=#firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)</a></li><li><a href=#firrtlintmodule-circtfirrtlfintmoduleop><code>firrtl.intmodule</code> (::circt::firrtl::FIntModuleOp)</a></li><li><a href=#firrtlmemmodule-circtfirrtlfmemmoduleop><code>firrtl.memmodule</code> (::circt::firrtl::FMemModuleOp)</a></li><li><a href=#firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)</a></li></ul></li><li><a href=#operation-definitions----declarations>Operation Definitions &ndash; Declarations</a><ul><li><a href=#firrtlintclock_gate-circtfirrtlclockgateintrinsicop><code>firrtl.int.clock_gate</code> (::circt::firrtl::ClockGateIntrinsicOp)</a></li><li><a href=#firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)</a></li><li><a href=#firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)</a></li><li><a href=#firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)</a></li><li><a href=#firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)</a></li><li><a href=#firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)</a></li><li><a href=#firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)</a></li></ul></li><li><a href=#statement-operation----statements>Statement Operation &ndash; Statements</a><ul><li><a href=#firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)</a></li><li><a href=#firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)</a></li><li><a href=#firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)</a></li><li><a href=#firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)</a></li><li><a href=#firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)</a></li><li><a href=#firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)</a></li><li><a href=#firrtlmatch-circtfirrtlmatchop><code>firrtl.match</code> (::circt::firrtl::MatchOp)</a></li><li><a href=#firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)</a></li><li><a href=#firrtlprobe-circtfirrtlprobeop><code>firrtl.probe</code> (::circt::firrtl::ProbeOp)</a></li><li><a href=#firrtlrefdefine-circtfirrtlrefdefineop><code>firrtl.ref.define</code> (::circt::firrtl::RefDefineOp)</a></li><li><a href=#firrtlrefforce_initial-circtfirrtlrefforceinitialop><code>firrtl.ref.force_initial</code> (::circt::firrtl::RefForceInitialOp)</a></li><li><a href=#firrtlrefforce-circtfirrtlrefforceop><code>firrtl.ref.force</code> (::circt::firrtl::RefForceOp)</a></li><li><a href=#firrtlrefrelease_initial-circtfirrtlrefreleaseinitialop><code>firrtl.ref.release_initial</code> (::circt::firrtl::RefReleaseInitialOp)</a></li><li><a href=#firrtlrefrelease-circtfirrtlrefreleaseop><code>firrtl.ref.release</code> (::circt::firrtl::RefReleaseOp)</a></li><li><a href=#firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)</a></li><li><a href=#firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)</a></li><li><a href=#firrtlstrictconnect-circtfirrtlstrictconnectop><code>firrtl.strictconnect</code> (::circt::firrtl::StrictConnectOp)</a></li><li><a href=#firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)</a></li></ul></li><li><a href=#operation-definitions----expressions>Operation Definitions &ndash; Expressions</a><ul><li><a href=#firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)</a></li><li><a href=#firrtlaggregateconstant-circtfirrtlaggregateconstantop><code>firrtl.aggregateconstant</code> (::circt::firrtl::AggregateConstantOp)</a></li><li><a href=#firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)</a></li><li><a href=#firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)</a></li><li><a href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)</a></li><li><a href=#firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)</a></li><li><a href=#firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)</a></li><li><a href=#firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)</a></li><li><a href=#firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)</a></li><li><a href=#firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)</a></li><li><a href=#firrtlbundlecreate-circtfirrtlbundlecreateop><code>firrtl.bundlecreate</code> (::circt::firrtl::BundleCreateOp)</a></li><li><a href=#firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)</a></li><li><a href=#firrtlconstcast-circtfirrtlconstcastop><code>firrtl.constCast</code> (::circt::firrtl::ConstCastOp)</a></li><li><a href=#firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)</a></li><li><a href=#firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)</a></li><li><a href=#firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)</a></li><li><a href=#firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)</a></li><li><a href=#firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)</a></li><li><a href=#firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)</a></li><li><a href=#firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)</a></li><li><a href=#firrtlelementwise_and-circtfirrtlelementwiseandprimop><code>firrtl.elementwise_and</code> (::circt::firrtl::ElementwiseAndPrimOp)</a></li><li><a href=#firrtlelementwise_or-circtfirrtlelementwiseorprimop><code>firrtl.elementwise_or</code> (::circt::firrtl::ElementwiseOrPrimOp)</a></li><li><a href=#firrtlelementwise_xor-circtfirrtlelementwisexorprimop><code>firrtl.elementwise_xor</code> (::circt::firrtl::ElementwiseXorPrimOp)</a></li><li><a href=#firrtlenumcreate-circtfirrtlfenumcreateop><code>firrtl.enumcreate</code> (::circt::firrtl::FEnumCreateOp)</a></li><li><a href=#firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)</a></li><li><a href=#firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)</a></li><li><a href=#firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)</a></li><li><a href=#firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)</a></li><li><a href=#firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)</a></li><li><a href=#firrtlistag-circtfirrtlistagop><code>firrtl.istag</code> (::circt::firrtl::IsTagOp)</a></li><li><a href=#firrtlintisx-circtfirrtlisxintrinsicop><code>firrtl.int.isX</code> (::circt::firrtl::IsXIntrinsicOp)</a></li><li><a href=#firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)</a></li><li><a href=#firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)</a></li><li><a href=#firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)</a></li><li><a href=#firrtlmultibit_mux-circtfirrtlmultibitmuxop><code>firrtl.multibit_mux</code> (::circt::firrtl::MultibitMuxOp)</a></li><li><a href=#firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)</a></li><li><a href=#firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)</a></li><li><a href=#firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)</a></li><li><a href=#firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)</a></li><li><a href=#firrtlopensubfield-circtfirrtlopensubfieldop><code>firrtl.opensubfield</code> (::circt::firrtl::OpenSubfieldOp)</a></li><li><a href=#firrtlopensubindex-circtfirrtlopensubindexop><code>firrtl.opensubindex</code> (::circt::firrtl::OpenSubindexOp)</a></li><li><a href=#firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)</a></li><li><a href=#firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)</a></li><li><a href=#firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)</a></li><li><a href=#firrtlintplusargstest-circtfirrtlplusargstestintrinsicop><code>firrtl.int.plusargs.test</code> (::circt::firrtl::PlusArgsTestIntrinsicOp)</a></li><li><a href=#firrtlintplusargsvalue-circtfirrtlplusargsvalueintrinsicop><code>firrtl.int.plusargs.value</code> (::circt::firrtl::PlusArgsValueIntrinsicOp)</a></li><li><a href=#firrtlrefresolve-circtfirrtlrefresolveop><code>firrtl.ref.resolve</code> (::circt::firrtl::RefResolveOp)</a></li><li><a href=#firrtlrefsend-circtfirrtlrefsendop><code>firrtl.ref.send</code> (::circt::firrtl::RefSendOp)</a></li><li><a href=#firrtlrefsub-circtfirrtlrefsubop><code>firrtl.ref.sub</code> (::circt::firrtl::RefSubOp)</a></li><li><a href=#firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)</a></li><li><a href=#firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)</a></li><li><a href=#firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)</a></li><li><a href=#firrtlintsizeof-circtfirrtlsizeofintrinsicop><code>firrtl.int.sizeof</code> (::circt::firrtl::SizeOfIntrinsicOp)</a></li><li><a href=#firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)</a></li><li><a href=#firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)</a></li><li><a href=#firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)</a></li><li><a href=#firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)</a></li><li><a href=#firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)</a></li><li><a href=#firrtlsubtag-circtfirrtlsubtagop><code>firrtl.subtag</code> (::circt::firrtl::SubtagOp)</a></li><li><a href=#firrtltagextract-circtfirrtltagextractop><code>firrtl.tagextract</code> (::circt::firrtl::TagExtractOp)</a></li><li><a href=#firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)</a></li><li><a href=#firrtlresetcast-circtfirrtluninferredresetcastop><code>firrtl.resetCast</code> (::circt::firrtl::UninferredResetCastOp)</a></li><li><a href=#firrtlwidthcast-circtfirrtluninferredwidthcastop><code>firrtl.widthCast</code> (::circt::firrtl::UninferredWidthCastOp)</a></li><li><a href=#firrtlvectorcreate-circtfirrtlvectorcreateop><code>firrtl.vectorcreate</code> (::circt::firrtl::VectorCreateOp)</a></li><li><a href=#firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)</a></li><li><a href=#firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)</a></li><li><a href=#firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)</a></li><li><a href=#firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)</a></li></ul></li><li><a href=#type-definitions>Type Definitions</a><ul><li><a href=#analogtype>AnalogType</a></li><li><a href=#asyncresettype>AsyncResetType</a></li><li><a href=#bundletype>BundleType</a></li><li><a href=#clocktype>ClockType</a></li><li><a href=#fenumtype>FEnumType</a></li><li><a href=#fvectortype>FVectorType</a></li><li><a href=#openbundletype>OpenBundleType</a></li><li><a href=#openvectortype>OpenVectorType</a></li><li><a href=#reftype>RefType</a></li><li><a href=#resettype>ResetType</a></li><li><a href=#sinttype>SIntType</a></li><li><a href=#stringtype>StringType</a></li><li><a href=#uinttype>UIntType</a></li></ul></li><li><a href=#attribute-definitions>Attribute Definitions</a><ul><li><a href=#augmentedbooleantypeattr>AugmentedBooleanTypeAttr</a></li><li><a href=#augmentedbundletypeattr>AugmentedBundleTypeAttr</a></li><li><a href=#augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</a></li><li><a href=#augmenteddoubletypeattr>AugmentedDoubleTypeAttr</a></li><li><a href=#augmentedgroundtypeattr>AugmentedGroundTypeAttr</a></li><li><a href=#augmentedintegertypeattr>AugmentedIntegerTypeAttr</a></li><li><a href=#augmentedliteraltypeattr>AugmentedLiteralTypeAttr</a></li><li><a href=#augmentedstringtypeattr>AugmentedStringTypeAttr</a></li><li><a href=#augmentedvectortypeattr>AugmentedVectorTypeAttr</a></li><li><a href=#memoryinitattr>MemoryInitAttr</a></li><li><a href=#paramdeclattr>ParamDeclAttr</a></li></ul></li><li><a href=#fconnectlike-fconnectlike>FConnectLike (<code>FConnectLike</code>)</a><ul><li><a href=#methods>Methods:</a></li></ul></li><li><a href=#fmodulelike-fmodulelike>FModuleLike (<code>FModuleLike</code>)</a><ul><li><a href=#methods-1>Methods:</a></li></ul></li><li><a href=#fnamableop-fnamableop>FNamableOp (<code>FNamableOp</code>)</a><ul><li><a href=#methods-2>Methods:</a></li></ul></li><li><a href=#forceable-forceable>Forceable (<code>Forceable</code>)</a><ul><li><a href=#methods-3>Methods:</a></li></ul></li></ul></nav><h2 id=operation-definitions----structure>Operation Definitions &ndash; Structure</h2><h3 id=firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)</h3><p>FIRRTL Circuit</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.circuit` $name `` custom&lt;CircuitOpAttrs&gt;(attr-dict) $body
</code></pre><p>The &ldquo;firrtl.circuit&rdquo; operation represents an overall Verilog circuit,
containing a list of modules.</p><p>Traits: InnerRefNamespace, IsolatedFromAbove, NoRegionArguments, NoTerminator, SingleBlock, SymbolTable</p><h4 id=attributes>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h3 id=firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)</h3><p>FIRRTL external module</p><p>The &ldquo;firrtl.extmodule&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.
LowerAnnotations can add RefType ports to it. Each RefType port
must have a corresponding entry in the internalPaths attribute.
The internalPaths attribute is used to represent opaque internal paths
into the external module, to be used for generating XMRs. Each RefType
port must be removed by LowerXMR pass.</p><p>Traits: HasParent<circuitop>, InnerSymbolTable, IsolatedFromAbove</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defname</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>convention</code></td><td style=text-align:center>::circt::firrtl::ConventionAttr</td><td>lowering convention</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>internalPaths</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h3 id=firrtlintmodule-circtfirrtlfintmoduleop><code>firrtl.intmodule</code> (::circt::firrtl::FIntModuleOp)</h3><p>FIRRTL intrinsic module</p><p>The &ldquo;firrtl.intmodule&rdquo; operation represents a compiler intrinsic.</p><p>Traits: HasParent<circuitop>, InnerSymbolTable, IsolatedFromAbove</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>intrinsic</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>internalPaths</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h3 id=firrtlmemmodule-circtfirrtlfmemmoduleop><code>firrtl.memmodule</code> (::circt::firrtl::FMemModuleOp)</h3><p>FIRRTL Generated Memory Module</p><p>The &ldquo;firrtl.memmodule&rdquo; operation represents an external reference to a
memory module. See the &ldquo;firrtl.mem&rdquo; op for a deeper explantation of the
parameters.</p><p>A &ldquo;firrtl.mem&rdquo; operation is typically lowered to this operation when they
are not directly lowered to registers by the compiler.</p><p>Traits: HasParent<circuitop>, InnerSymbolTable, IsolatedFromAbove</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>numReadPorts</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>numWritePorts</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>numReadWritePorts</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>dataWidth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>maskBits</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>readLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>writeLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>depth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>extraPorts</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h3 id=firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)</h3><p>FIRRTL Module</p><p>The &ldquo;firrtl.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, and a body that represents the connections within
the module.</p><p>Traits: HasParent<circuitop>, InnerSymbolTable, IsolatedFromAbove, NoTerminator, SingleBlock</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>convention</code></td><td style=text-align:center>::circt::firrtl::ConventionAttr</td><td>lowering convention</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h2 id=operation-definitions----declarations>Operation Definitions &ndash; Declarations</h2><h3 id=firrtlintclock_gate-circtfirrtlclockgateintrinsicop><code>firrtl.int.clock_gate</code> (::circt::firrtl::ClockGateIntrinsicOp)</h3><p>Safely gates a clock with an enable signal</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.clock_gate` $input `,` $enable (`,` $test_enable^)? attr-dict
</code></pre><p>The <code>int.clock_gate</code> enables and disables a clock safely, without glitches,
based on a boolean enable value. If the enable input is 1, the output clock
produced by the clock gate is identical to the input clock. If the enable
input is 0, the output clock is a constant zero.</p><p>The enable input is sampled at the rising edge of the input clock; any
changes on the enable before or after that edge are ignored and do not
affect the output clock.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>clock</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>test_enable</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)</h3><p>Instantiate an instance of a module</p><p>This represents an instance of a module. The results are the modules inputs
and outputs. The inputs have flip type, the outputs do not.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>instance foo <span class=nf>@Foo</span><span class=p>(</span>in io<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>)</span>
</span></span></code></pre></div><p>Traits: HasParent&lt;firrtl::FModuleOp, firrtl::WhenOp></p><p>Interfaces: FNamableOp, HWInstanceLike, HasCustomSSAName, InnerSymbolOpInterface, SymbolUserOpInterface</p><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>moduleName</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>portDirections</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td style=text-align:center><code>portNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>portAnnotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td style=text-align:center><code>lowerToBind</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)</h3><p>Define a new mem</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mem` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              $ruw `` custom&lt;MemOp&gt;(attr-dict) `:` qualified(type($results))
</code></pre><p>Interfaces: FNamableOp, HasCustomSSAName, InnerSymbolOpInterface</p><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0</td></tr><tr><td style=text-align:center><code>writeLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td style=text-align:center><code>depth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td style=text-align:center><code>ruw</code></td><td style=text-align:center>::RUWAttrAttr</td><td>Read Under Write Enum</td></tr><tr><td style=text-align:center><code>portNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>portAnnotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td style=text-align:center><code>init</code></td><td style=text-align:center>::circt::firrtl::MemoryInitAttr</td><td>Information about the initial state of a memory</td></tr><tr><td style=text-align:center><code>prefix</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)</h3><p>No-op to name a value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.node` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              $input (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict) `:` qualified(type($input))
</code></pre><p>A node is simply a named intermediate value in a circuit. The node must
be initialized to a value with a passive type and cannot be connected to.
Nodes are often used to split a complicated compound expression into named
subexpressions.</p><pre tabindex=0><code>  %result = firrtl.node %input : t1
</code></pre><p>Interfaces: FNamableOp, Forceable, HasCustomSSAName, InferTypeOpInterface, InnerSymbolOpInterface</p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td style=text-align:center><code>forceable</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)</h3><p>Define a new register</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.reg` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              operands (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict) `:` type($clockVal) `,` qualified(type($result)) (`,` qualified(type($ref))^)?
</code></pre><p>Declare a new register:</p><pre tabindex=0><code>%name = firrtl.reg %clockVal : !firrtl.clock, t1
</code></pre><p>Interfaces: FNamableOp, Forceable, HasCustomSSAName, InnerSymbolOpInterface</p><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td style=text-align:center><code>forceable</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockVal</code></td><td>clock</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive non-&lsquo;const&rsquo; base type that does not contain analog</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)</h3><p>Define a new register with a reset</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.regreset` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              operands (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict)
              `:` type($clockVal) `,` qualified(type($resetSignal)) `,` qualified(type($resetValue)) `,` qualified(type($result)) (`,` qualified(type($ref))^)?
</code></pre><p>Declare a new register:</p><pre tabindex=0><code>  %name = firrtl.regreset %clockVal, %resetSignal, %resetValue : !firrtl.clock, t1
</code></pre><p>Interfaces: FNamableOp, Forceable, HasCustomSSAName, InnerSymbolOpInterface</p><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td style=text-align:center><code>forceable</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockVal</code></td><td>clock</td></tr><tr><td style=text-align:center><code>resetSignal</code></td><td>Reset</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>a base type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive non-&lsquo;const&rsquo; base type that does not contain analog</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)</h3><p>Define a new wire</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.wire` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict) `:`
              qualified(type($result)) (`,` qualified(type($ref))^)?
</code></pre><p>Declare a new wire:</p><pre tabindex=0><code>  %name = firrtl.wire : t1
</code></pre><p>Interfaces: FNamableOp, Forceable, HasCustomSSAName, InnerSymbolOpInterface</p><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td style=text-align:center><code>forceable</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h2 id=statement-operation----statements>Statement Operation &ndash; Statements</h2><h3 id=firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)</h3><p>Assert Verification Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.assert` $clock `,` $predicate `,` $enable `,`
              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>isConcurrent</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>eventControl</code></td><td style=text-align:center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)</h3><p>Assume Verification Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.assume` $clock `,` $predicate `,` $enable `,`
              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>isConcurrent</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>eventControl</code></td><td style=text-align:center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)</h3><p>Analog Attach Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.attach` $attached attr-dict `:` qualified(type($attached))
</code></pre><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attached</code></td><td>analog type</td></tr></tbody></table><h3 id=firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)</h3><p>Connect two signals</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.connect` $dest `,` $src  attr-dict `:` qualified(type($dest)) `,` qualified(type($src))
</code></pre><p>Connect Operation:</p><pre tabindex=0><code>  firrtl.connect %dest, %src : t1, t2
</code></pre><p>Interfaces: FConnectLike</p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a base type or foreign type or StringType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type or foreign type or StringType</td></tr></tbody></table><h3 id=firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)</h3><p>Cover Verification Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cover` $clock `,` $predicate `,` $enable `,`
              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>isConcurrent</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>eventControl</code></td><td style=text-align:center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)</h3><p>Force procedural statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.force` $dest `,` $src attr-dict `:` qualified(type($dest)) `,` qualified(type($src))
</code></pre><p>Maps to the corresponding <code>sv.force</code> operation.
Traits: SameTypeOperands</p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a base type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlmatch-circtfirrtlmatchop><code>firrtl.match</code> (::circt::firrtl::MatchOp)</h3><p>Match Statement</p><p>The &ldquo;firrtl.match&rdquo; operation represents a pattern matching statement on a
enumeration. This operation does not return a value and cannot be used as an
expression. Last connect semantics work similarly to a when statement.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  firrtl<span class=p>.</span>match <span class=nv>%in</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>enum<span class=p>&lt;</span>Some<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> None<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    case Some<span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>firrtl<span class=p>.</span>strictconnect <span class=nv>%w</span><span class=p>,</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    case None<span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>firrt<span class=p>.</span>strictconnect <span class=nv>%w</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>Traits: NoTerminator, RecursiveMemoryEffects, RecursivelySpeculatableImplTrait, SingleBlock</p><p>Interfaces: ConditionallySpeculatable</p><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tags</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></tbody></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FEnumType</td></tr></tbody></table><h3 id=firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)</h3><p>Formatted Print Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.printf` $clock `,` $cond `,` $formatString `` custom&lt;PrintfAttrs&gt;(attr-dict) ` `
              (`(` $substitutions^ `)`)? `:` type($clock) `,` type($cond) (`,` qualified(type($substitutions))^)?
</code></pre><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>formatString</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>cond</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlprobe-circtfirrtlprobeop><code>firrtl.probe</code> (::circt::firrtl::ProbeOp)</h3><p>FIRRTL Value Probe</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.probe` $inner_sym attr-dict ( `,` $captured^  `:` qualified(type($captured)))?
</code></pre><p>Captures values without binding to any accidental name.</p><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>captured</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefdefine-circtfirrtlrefdefineop><code>firrtl.ref.define</code> (::circt::firrtl::RefDefineOp)</h3><p>FIRRTL Define References</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.define` $dest `,` $src  attr-dict `:` qualified(type($dest))
</code></pre><p>Define a target reference to the source reference:</p><pre tabindex=0><code>  firrtl.ref.define %dest, %src : ref&lt;t1&gt;
</code></pre><p>Used to statically route reference from source to destination
through the design, one module at a time.</p><p>Similar to &ldquo;connect&rdquo; but cannot have multiple define&rsquo;s to same
destination and the define is never conditional even if under
a &ldquo;when&rdquo;.</p><p>Source and destination must resolve statically.</p><p>Traits: SameTypeOperands</p><p>Interfaces: FConnectLike</p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>reference type</td></tr><tr><td style=text-align:center><code>src</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrefforce_initial-circtfirrtlrefforceinitialop><code>firrtl.ref.force_initial</code> (::circt::firrtl::RefForceInitialOp)</h3><p>FIRRTL force_initial statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.force_initial` $predicate `,` $dest `,` $src attr-dict `:` type($predicate) `,` qualified(type($src))
</code></pre><p>Force a RWProbe to the specified value continuously.</p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefforce-circtfirrtlrefforceop><code>firrtl.ref.force</code> (::circt::firrtl::RefForceOp)</h3><p>FIRRTL force statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.force` $clock `,` $predicate `,` $dest `,` $src attr-dict `:` type($clock) `,` type($predicate) `,` qualified(type($src))
</code></pre><p>Force a RWProbe to the specified value using the specified clock and predicate.</p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefrelease_initial-circtfirrtlrefreleaseinitialop><code>firrtl.ref.release_initial</code> (::circt::firrtl::RefReleaseInitialOp)</h3><p>FIRRTL release_initial statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.release_initial` $predicate `,` $dest attr-dict `:` type($predicate) `,` qualified(type($dest))
</code></pre><p>Release the target RWProbe.</p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr></tbody></table><h3 id=firrtlrefrelease-circtfirrtlrefreleaseop><code>firrtl.ref.release</code> (::circt::firrtl::RefReleaseOp)</h3><p>FIRRTL release statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.release` $clock `,` $predicate `,` $dest attr-dict `:` type($clock) `,` type($predicate) `,` qualified(type($dest))
</code></pre><p>Release the target RWProbe using the specified clock and predicate.</p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr></tbody></table><h3 id=firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)</h3><p>Skip statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.skip` attr-dict
</code></pre><p>Skip Statement:</p><pre tabindex=0><code>   %firrtl.skip
</code></pre><p>This is a no-op statement.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h3 id=firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)</h3><p>Stop Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.stop` $clock `,` $cond `,` $exitCode `` custom&lt;StopAttrs&gt;(attr-dict) `:` type($clock) `,` type($cond)
</code></pre><h4 id=attributes-17>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>exitCode</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>cond</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlstrictconnect-circtfirrtlstrictconnectop><code>firrtl.strictconnect</code> (::circt::firrtl::StrictConnectOp)</h3><p>Connect two signals</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.strictconnect` $dest `,` $src  attr-dict `:` qualified(type($dest))
</code></pre><p>Connect two values with strict constraints:</p><pre tabindex=0><code>  firrtl.strictconnect %dest, %src : t1
</code></pre><p>Traits: SameTypeOperands</p><p>Interfaces: FConnectLike</p><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a passive base type (contain no flips) or foreign type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a passive base type (contain no flips) or foreign type</td></tr></tbody></table><h3 id=firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)</h3><p>When Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.when` $condition `:` type($condition) $thenRegion (`else` $elseRegion^)? attr-dict-with-keyword
</code></pre><p>The &ldquo;firrtl.when&rdquo; operation represents a conditional. Connections within
a conditional statement that connect to previously declared components hold
only when the given condition is high. The condition must have a 1-bit
unsigned integer type.</p><p>Traits: NoRegionArguments, NoTerminator, RecursiveMemoryEffects, RecursivelySpeculatableImplTrait, SingleBlock</p><p>Interfaces: ConditionallySpeculatable</p><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit uint</td></tr></tbody></table><h2 id=operation-definitions----expressions>Operation Definitions &ndash; Expressions</h2><h3 id=firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.add` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlaggregateconstant-circtfirrtlaggregateconstantop><code>firrtl.aggregateconstant</code> (::circt::firrtl::AggregateConstantOp)</h3><p>Produce a constant of a passive aggregate value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.aggregateconstant` $fields attr-dict `:` type($result)
</code></pre><p>The constant operation produces a constant value of an aggregate type. The
type must be passive. Clock and reset values are supported.
For nested aggregates, embedded arrays are used.</p><pre tabindex=0><code>  %result = firrtl.aggregateconstant [1, 2, 3] : !firrtl.bundle&lt;a: uint&lt;8&gt;, b: uint&lt;5&gt;, c: uint&lt;4&gt;&gt;
  %result = firrtl.aggregateconstant [1, 2, 3] : !firrtl.vector&lt;uint&lt;8&gt;, 3&gt;
  %result = firrtl.aggregateconstant [[1, 2], [3, 5]] : !firrtl.vector&lt;!firrtl.bundle&lt;a: uint&lt;8&gt;, b: uint&lt;5&gt;&gt;, 2&gt;
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-18>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a aggregate type</td></tr></tbody></table><h3 id=firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.and` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.andr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;and&rsquo; operation to merge
bits. <code>andr(x)</code> is equivalent to <code>concat(x, 1b1) == ~0</code>. As such, it
returns 1 for zero-bit-wide operands.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asAsyncReset` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>AsyncReset</td></tr></tbody></table><h3 id=firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asClock` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asSInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asUInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)</h3><pre><code>Reinterpret one value to another value of the same size and
potentially different type. This op is lowered to hw::BitCastOp.
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bits` $input $hi `to` $lo attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>bits</code> operation extracts the bits between <code>hi</code> (inclusive) and <code>lo</code>
(inclusive) from <code>input</code>. <code>hi</code> must be greater than or equal to <code>lo</code>. Both
<code>hi</code> and <code>lo</code> must be non-negative and less than the bit width of <code>input</code>.
The result is <code>hi - lo + 1</code> bits wide.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>hi</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>lo</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlbundlecreate-circtfirrtlbundlecreateop><code>firrtl.bundlecreate</code> (::circt::firrtl::BundleCreateOp)</h3><p>Produce a bundle value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bundlecreate` $fields attr-dict `:` functional-type($fields, $result)
</code></pre><p>Create an bundle from component values. This is equivalent in terms of
flow to creating a node.</p><pre tabindex=0><code>  %result = firrtl.bundlecreate %1, %2, %3 : !firrtl.bundle&lt;a: uint&lt;8&gt;, b: uint&lt;5&gt;, c: uint&lt;4&gt;&gt;
</code></pre><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td>a base type</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>BundleType</td></tr></tbody></table><h3 id=firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cat` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlconstcast-circtfirrtlconstcastop><code>firrtl.constCast</code> (::circt::firrtl::ConstCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.constCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Cast from a &lsquo;const&rsquo; to a non-&lsquo;const&rsquo; type.</p><pre tabindex=0><code>%result = firrtl.constCast %in : (!firrtl.const.t1) -&gt; !firrtl.t1
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)</h3><p>Produce a constant value</p><p>The constant operation produces a constant value of SInt or UInt type, it
never produces a zero bit wide result.</p><pre tabindex=0><code>  %result = firrtl.constant 42 : t1
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-20>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>arbitrary integer attribute with sign</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cvt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshl` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>A dynamic shift left operation. The width of <code>$result</code> is expanded to
<code>width($lhs) + 1 &lt;&lt; width($rhs) - 1</code>.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-34>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshlw` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>A dynamic shift left operation same as &lsquo;dshl&rsquo; but with different width rule.
The width of <code>$result</code> is equal to <code>$lhs</code>.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-35>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshr` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-36>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.div` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Divides the first argument (the numerator) by the second argument
(the denominator) truncating the result (rounding towards zero).</p><p><strong>If the denominator is zero, the result is undefined.</strong></p><p>The compiler may optimize this undefined behavior in any way it
wants. Notably <code>div(a, a)</code> will be optimized to <code>1</code>. This may cause
erroneous formal equivalence mismatches between unoptimized and
optimized FIRRTL dialects that are separately converted to Verilog.</p><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-37>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.eq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-38>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlelementwise_and-circtfirrtlelementwiseandprimop><code>firrtl.elementwise_and</code> (::circt::firrtl::ElementwiseAndPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.elementwise_and` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-39>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1d vector with Int element type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1d vector with Int element type</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1d vector with UInt element type</td></tr></tbody></table><h3 id=firrtlelementwise_or-circtfirrtlelementwiseorprimop><code>firrtl.elementwise_or</code> (::circt::firrtl::ElementwiseOrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.elementwise_or` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-40>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1d vector with Int element type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1d vector with Int element type</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1d vector with UInt element type</td></tr></tbody></table><h3 id=firrtlelementwise_xor-circtfirrtlelementwisexorprimop><code>firrtl.elementwise_xor</code> (::circt::firrtl::ElementwiseXorPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.elementwise_xor` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-41>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1d vector with UInt element type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1d vector with Int element type</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1d vector with UInt element type</td></tr></tbody></table><h3 id=firrtlenumcreate-circtfirrtlfenumcreateop><code>firrtl.enumcreate</code> (::circt::firrtl::FEnumCreateOp)</h3><p>Produce a enum value</p><p>Create an enum from tag and value.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%result</span> <span class=p>=</span> firrtl<span class=p>.</span>enumcreate field<span class=err>-</span>name<span class=p>(</span><span class=nv>%input</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>enum<span class=p>&lt;</span>None<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;,</span> Some<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>8</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h4 id=attributes-21>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fieldIndex</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-42>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FEnumType</td></tr></tbody></table><h3 id=firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.geq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-43>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.gt` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-44>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.hwStructCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-45>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.head` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-22>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-46>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-34>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)</h3><p>InvalidValue primitive</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.invalidvalue` attr-dict `:` qualified(type($result))
</code></pre><p>The InvalidValue operation returns an invalid value of a specified type:</p><pre tabindex=0><code>  %result = firrtl.invalid : !firrtl.uint&lt;1&gt;
</code></pre><p>This corresponds to the FIRRTL invalidate operation without the implicit
connect semantics. Each invalid op produces a unique invalid value.
InvalidOp is not constant-like</p><p>Interfaces: HasCustomSSAName, MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p><h4 id=results-35>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlistag-circtfirrtlistagop><code>firrtl.istag</code> (::circt::firrtl::IsTagOp)</h3><p>Test the active variant of an enumeration</p><p>This operation is used to test the active variant of an enumeration. The
tag tested for must be one of the possible variants of the input type. If
the tag is the currently active variant the result will be 1, otherwise the
result will be 0.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>istag A <span class=nv>%v</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>enum<span class=p>&lt;</span>A<span class=p>:</span> UInt<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;,</span> B<span class=p>:</span> UInt<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-23>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fieldIndex</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-47>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FEnumType</td></tr></tbody></table><h4 id=results-36>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintisx-circtfirrtlisxintrinsicop><code>firrtl.int.isX</code> (::circt::firrtl::IsXIntrinsicOp)</h3><p>Test for &lsquo;x</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.isX` $arg attr-dict `:` type($arg)
</code></pre><p>The <code>int.isX</code> expression checks that the operand is not a verilog literal
&lsquo;x. FIRRTL doesn&rsquo;t have a notion of &lsquo;x per-se, but x can come in to the
system from external modules and from SV constructs. Verification
constructs need to explicitly test for &lsquo;x.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-48>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>a base type</td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.leq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-49>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.lt` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-50>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mul` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-51>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlmultibit_mux-circtfirrtlmultibitmuxop><code>firrtl.multibit_mux</code> (::circt::firrtl::MultibitMuxOp)</h3><p>Multibit multiplexer</p><p>The multibit mux expression dynamically selects operands. The
index must be an expression with an unsigned integer type.</p><pre tabindex=0><code>  %result = firrtl.multibit_mux %index,
            %v_{n-1}, ..., %v_2, %v_1, %v_0  : t1, t2
</code></pre><p>The order of operands is defined in the same way as hw dialect.
For the example above, if <code>%index</code> is 0, then the value is <code>%v_0</code>.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-52>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td>uint type</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>a base type</td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mux` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-53>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sel</code></td><td>1-bit uint or uint with uninferred width</td></tr><tr><td style=text-align:center><code>high</code></td><td>a passive base type (contain no flips)</td></tr><tr><td style=text-align:center><code>low</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-42>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.neq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-54>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.neg` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-55>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.not` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-56>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlopensubfield-circtfirrtlopensubfieldop><code>firrtl.opensubfield</code> (::circt::firrtl::OpenSubfieldOp)</h3><p>Extract a subfield of another value</p><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre tabindex=0><code>  %result = firrtl.opensubfield %input[field-name] : !input-type
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-24>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fieldIndex</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-57>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>OpenBundleType</td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlopensubindex-circtfirrtlopensubindexop><code>firrtl.opensubindex</code> (::circt::firrtl::OpenSubindexOp)</h3><p>Extract an element of a vector value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.opensubindex` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre tabindex=0><code>  %result = firrtl.opensubindex %input[index] : t1
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-25>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-58>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>OpenVectorType</td></tr></tbody></table><h4 id=results-47>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.or` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-59>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-48>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.orr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;or&rsquo; operation to merge
bits. <code>orr(x)</code> is equivalent to <code>concat(x, 1b0) != 0</code>. As such, it
returns 0 for zero-bit-wide operands.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-60>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-49>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.pad` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Pad the input out to an <code>amount</code> wide integer, sign extending or zero
extending according to <code>input</code>s type. If <code>amount</code> is less than the existing
width of <code>input</code>, then input is unmodified.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-26>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-61>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-50>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlintplusargstest-circtfirrtlplusargstestintrinsicop><code>firrtl.int.plusargs.test</code> (::circt::firrtl::PlusArgsTestIntrinsicOp)</h3><p>SystemVerilog <code>$test$plusargs</code> call</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.plusargs.test` $formatString attr-dict
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-27>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>formatString</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-51>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>found</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintplusargsvalue-circtfirrtlplusargsvalueintrinsicop><code>firrtl.int.plusargs.value</code> (::circt::firrtl::PlusArgsValueIntrinsicOp)</h3><p>SystemVerilog <code>$value$plusargs</code> call</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.plusargs.value` $formatString attr-dict `:` type($result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-28>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>formatString</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-52>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>found</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlrefresolve-circtfirrtlrefresolveop><code>firrtl.ref.resolve</code> (::circt::firrtl::RefResolveOp)</h3><p>FIRRTL Resolve a Reference</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.resolve` $ref attr-dict `:` qualified(type($ref))
</code></pre><p>Resolve a remote reference for reading a remote value.
It takes a RefType input and returns the corresponding BaseType value.
If an XMR is emitted for this reference, it will be at the location
of this operation.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-62>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h4 id=results-53>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefsend-circtfirrtlrefsendop><code>firrtl.ref.send</code> (::circt::firrtl::RefSendOp)</h3><p>FIRRTL Send through Reference</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.send` $base attr-dict `:` qualified(type($base))
</code></pre><p>Endpoint of a remote reference. Send a value through a reference
to be read from the firrtl.ref.resolve op.
It takes a BaseType input and returns the corresponding RefType value.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-63>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>a base type</td></tr></tbody></table><h4 id=results-54>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrefsub-circtfirrtlrefsubop><code>firrtl.ref.sub</code> (::circt::firrtl::RefSubOp)</h3><p>Extract an element of an aggregate RefType value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.sub` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The refsub expression statically refers, by index, to a sub-element
of an expression with a RefType. The index must be a non-negative
integer and cannot be equal to or exceed the underlying vector size
or number of elements in bundle.</p><pre tabindex=0><code>  %result = firrtl.ref.sub %input[index] : t1
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-29>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-64>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>reference type</td></tr></tbody></table><h4 id=results-55>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.rem` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-65>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-56>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.shl` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shl</code> operation concatenates <code>amount</code> zero bits to the least significant
end of <code>input</code>. <code>amount</code> must be non-negative.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-30>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-66>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-57>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.shr` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shr</code> operation truncates least significant <code>amount</code> bits from <code>input</code>.
If <code>amount</code> is greater than of equal to <code>width(input)</code>, the value will be
zero for unsigned types and the sign bit for signed types. <code>amount</code> must be
non-negative.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-31>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-67>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-58>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlintsizeof-circtfirrtlsizeofintrinsicop><code>firrtl.int.sizeof</code> (::circt::firrtl::SizeOfIntrinsicOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.sizeof` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-68>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-59>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit uint</td></tr></tbody></table><h3 id=firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)</h3><p>Produce a constant Reset or Clock value</p><p>The constant operation produces a constant value of Reset, AsyncReset, or
Clock type. The value can only be 0 or 1.</p><pre tabindex=0><code>  %result = firrtl.specialconstant 1 : !firrtl.clock
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-32>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=results-60>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>clock or Reset or AsyncReset</td></tr></tbody></table><h3 id=firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.sub` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-69>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-61>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)</h3><p>Extract a dynamic element of a vector value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subaccess` $input `[` $index `]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))
</code></pre><p>The subaccess expression dynamically refers to a subelement of a
vector-typed expression using a calculated index. The index must be an
expression with an unsigned integer type.</p><pre tabindex=0><code>  %result = firrtl.subaccess %input[%idx] : t1, t2
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-70>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FVectorType</td></tr><tr><td style=text-align:center><code>index</code></td><td>uint type</td></tr></tbody></table><h4 id=results-62>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)</h3><p>Extract a subfield of another value</p><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre tabindex=0><code>  %result = firrtl.subfield %input[field-name] : !input-type
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-33>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fieldIndex</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-71>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>BundleType</td></tr></tbody></table><h4 id=results-63>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)</h3><p>Extract an element of a vector value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subindex` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre tabindex=0><code>  %result = firrtl.subindex %input[index] : t1
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-34>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-72>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FVectorType</td></tr></tbody></table><h4 id=results-64>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlsubtag-circtfirrtlsubtagop><code>firrtl.subtag</code> (::circt::firrtl::SubtagOp)</h3><p>Extract an element of a enum value</p><p>The subtag expression refers to a subelement of a
enum-typed expression.</p><pre tabindex=0><code>  %result = firrtl.subtag %input[field-name] : !input-type
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-35>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fieldIndex</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-73>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FEnumType</td></tr></tbody></table><h4 id=results-65>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtltagextract-circtfirrtltagextractop><code>firrtl.tagextract</code> (::circt::firrtl::TagExtractOp)</h3><p>Extract the tag from a value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.tagextract` $input attr-dict `:` qualified(type($input))
</code></pre><p>The tagextract expression returns the binary value of the current tag of an
enum value.</p><pre tabindex=0><code>  %result = firrtl.tagextract %input : !input-type
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-74>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FEnumType</td></tr></tbody></table><h4 id=results-66>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.tail` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>tail</code> operation truncates the <code>amount</code> most significant bits from
<code>input</code>. <code>amount</code> must be non-negative and less than or equal to the bit
width of e. The result is <code>width(input)-amount</code> bits wide.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-36>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-75>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-67>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlresetcast-circtfirrtluninferredresetcastop><code>firrtl.resetCast</code> (::circt::firrtl::UninferredResetCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.resetCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Cast between reset types. This is used to enable strictconnects early in
the pipeline by isolating all uninferred reset connections to a single op.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-76>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>Reset</td></tr></tbody></table><h4 id=results-68>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Reset</td></tr></tbody></table><h3 id=firrtlwidthcast-circtfirrtluninferredwidthcastop><code>firrtl.widthCast</code> (::circt::firrtl::UninferredWidthCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.widthCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Cast between sized and unsized integer types. This is used to enable
strictconnects early in the pipeline by isolating all uninferred width
connections to a single op.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-77>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-69>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlvectorcreate-circtfirrtlvectorcreateop><code>firrtl.vectorcreate</code> (::circt::firrtl::VectorCreateOp)</h3><p>Produce a vector value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.vectorcreate` $fields attr-dict `:` functional-type($fields, $result)
</code></pre><p>Create a vector from component values. This is equivalent in terms of
flow to creating a node. The first operand indicates 0-th element of
the result.</p><pre tabindex=0><code>  %result = firrtl.vectorcreate %1, %2, %3 : !firrtl.vector&lt;uint&lt;8&gt;, 3&gt;
</code></pre><h4 id=operands-78>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td>a base type</td></tr></tbody></table><h4 id=results-70>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FVectorType</td></tr></tbody></table><h3 id=firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)</h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.verbatim.expr` $text (`(` $substitutions^ `)`)?
              `:` functional-type($substitutions, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.expr</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-37>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>text</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-79>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>any type</td></tr></tbody></table><h4 id=results-71>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)</h3><p>Expression with wire semantics that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.verbatim.wire` $text (`(` $substitutions^ `)`)?
              `:` functional-type($substitutions, $result) attr-dict
</code></pre><p>This operation produces a typed value with wire semantics, expressed by a
string of SystemVerilog. This can be used to access macros and other values
that are only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.wire</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-38>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>text</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-80>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>any type</td></tr></tbody></table><h4 id=results-72>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xor` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsIntTypeKind</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-81>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-73>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xorr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;xor&rsquo; operation to merge
bits. <code>xorr(x)</code> is equivalent to <code>popcount(concat(x, 1b0)) & 1</code>. As
such, it returns 0 for zero-bit-wide operands.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, HasCustomSSAName, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-82>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-74>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h2 id=type-definitions>Type Definitions</h2><h3 id=analogtype>AnalogType</h3><p>Analog signal</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>widthOrSentinel</td><td style=text-align:center><code>int32_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=asyncresettype>AsyncResetType</h3><p>AsyncReset signal</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=bundletype>BundleType</h3><p>an aggregate of named elements. This is effectively a struct.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>ArrayRef&lt;BundleElement></code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=clocktype>ClockType</h3><p>Clock signal</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=fenumtype>FEnumType</h3><p>a sum type of named elements.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>ArrayRef&lt;EnumElement></code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=fvectortype>FVectorType</h3><p>a fixed size collection of elements, like an array.</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>lementType</td><td style=text-align:center><code>::circt::firrtl::FIRRTLBaseType</code></td><td>Type of vector elements</td></tr><tr><td style=text-align:center>numElements</td><td style=text-align:center><code>size_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=openbundletype>OpenBundleType</h3><p>an aggregate of named elements. This is effectively a struct.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>ArrayRef&lt;BundleElement></code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=openvectortype>OpenVectorType</h3><p>a fixed size collection of elements, like an array.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>lementType</td><td style=text-align:center><code>::circt::firrtl::FIRRTLType</code></td><td>Type of vector elements</td></tr><tr><td style=text-align:center>numElements</td><td style=text-align:center><code>size_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=reftype>RefType</h3><pre><code>A reference type, such as `firrtl.probe&lt;uint&lt;1&gt;&gt;` or `firrtl.rwprobe&lt;uint&lt;2&gt;&gt;`.

Used for remote reads and writes of the wrapped base type.

Parameterized over the referenced base type,
which must be passive and for now must also be ground.

Not a base type.

Values of this type are used to capture dataflow paths,
and do not represent a circuit element or entity.

Generally read-only (probe), optionally forceable (rwprobe).
</code></pre><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::circt::firrtl::FIRRTLBaseType</code></td><td>Type of reference target</td></tr><tr><td style=text-align:center>forceable</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=resettype>ResetType</h3><p>Reset Signal</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=sinttype>SIntType</h3><p>A signed integer type, whose width may not be known.</p><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>widthOrSentinel</td><td style=text-align:center><code>int32_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=stringtype>StringType</h3><pre><code>An unlimited length string type. Not representable in hardware.
</code></pre><h3 id=uinttype>UIntType</h3><p>An unsigned integer type, whose width may not be known.</p><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>widthOrSentinel</td><td style=text-align:center><code>int32_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h2 id=attribute-definitions>Attribute Definitions</h2><h3 id=augmentedbooleantypeattr>AugmentedBooleanTypeAttr</h3><p>GrandCentral AugmentedBooleanType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedbundletypeattr>AugmentedBundleTypeAttr</h3><p>GrandCentral AugmentedBundleType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-13>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</h3><p>GrandCentral AugmentedDeletedType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-14>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddoubletypeattr>AugmentedDoubleTypeAttr</h3><p>GrandCentral AugmentedDoubleType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-15>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedgroundtypeattr>AugmentedGroundTypeAttr</h3><p>GrandCentral AugmentedGroundType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-16>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedintegertypeattr>AugmentedIntegerTypeAttr</h3><p>GrandCentral AugmentedIntegerType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-17>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedliteraltypeattr>AugmentedLiteralTypeAttr</h3><p>GrandCentral AugmentedLiteralType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-18>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedstringtypeattr>AugmentedStringTypeAttr</h3><p>GrandCentral AugmentedStringType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-19>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedvectortypeattr>AugmentedVectorTypeAttr</h3><p>GrandCentral AugmentedVectorType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-20>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=memoryinitattr>MemoryInitAttr</h3><p>Information about the initial state of a memory</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.meminit&lt;
  ::mlir::StringAttr,   # filename
  bool,   # isBinary
  bool   # isInline
&gt;
</code></pre><p>This attribute captures information about the external initialization of a
memory. This is the FIRRTL Dialect representation of both
&ldquo;firrtl.annotations.LoadMemoryFromFile&rdquo; and
&ldquo;firrtl.annotations.MemoryFileInlineAnnotation&rdquo;.</p><h4 id=parameters-21>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>isBinary</td><td style=text-align:center><code>bool</code></td><td></td></tr><tr><td style=text-align:center>isInline</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=paramdeclattr>ParamDeclAttr</h3><p>Module or instance parameter definition</p><p>An attribute describing a module parameter, or instance parameter
specification.</p><h4 id=parameters-22>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=fconnectlike-fconnectlike>FConnectLike (<code>FConnectLike</code>)</h2><p>Provide common connection information.</p><h3 id=methods>Methods:</h3><h4 id=getdest><code>getDest</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Value</span> <span class=nf>getDest</span><span class=p>();</span>
</span></span></code></pre></div><p>Return a destination of connection.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getsrc><code>getSrc</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Value</span> <span class=nf>getSrc</span><span class=p>();</span>
</span></span></code></pre></div><p>Return a source of connection.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getconnectbehaviorkind><code>getConnectBehaviorKind</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>ConnectBehaviorKind</span> <span class=nf>getConnectBehaviorKind</span><span class=p>();</span>
</span></span></code></pre></div><p>Return connection behavior kind.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=hasstaticsingleconnectbehavior><code>hasStaticSingleConnectBehavior</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>hasStaticSingleConnectBehavior</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns true if ConnectBehavior is StaticSingleConnect.</p><h4 id=haslastconnectbehavior><code>hasLastConnectBehavior</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>hasLastConnectBehavior</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns true if ConnectBehavior is LastConnect.</p><h2 id=fmodulelike-fmodulelike>FModuleLike (<code>FModuleLike</code>)</h2><p>Provide common module information.</p><h3 id=methods-1>Methods:</h3><h4 id=getparameters><code>getParameters</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getParameters</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the parameters</p><h4 id=getconventionattr><code>getConventionAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ConventionAttr</span> <span class=nf>getConventionAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module&rsquo;s instantiation convention
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getconvention><code>getConvention</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Convention</span> <span class=nf>getConvention</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module&rsquo;s instantiation convention
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportdirectionsattr><code>getPortDirectionsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>IntegerAttr</span> <span class=nf>getPortDirectionsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port directions attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportdirections><code>getPortDirections</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>APInt</span> <span class=nf>getPortDirections</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port directions
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportdirection><code>getPortDirection</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Direction</span> <span class=nf>getPortDirection</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port direction
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportnamesattr><code>getPortNamesAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortNamesAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port names attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportnames><code>getPortNames</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortNames</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port names
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportnameattr><code>getPortNameAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringAttr</span> <span class=nf>getPortNameAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port name
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportname><code>getPortName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringRef</span> <span class=nf>getPortName</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port name
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttypesattr><code>getPortTypesAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortTypesAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port types attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttypes><code>getPortTypes</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortTypes</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port types
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttypeattr><code>getPortTypeAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>TypeAttr</span> <span class=nf>getPortTypeAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port type
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttype><code>getPortType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Type</span> <span class=nf>getPortType</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port type
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportannotationsattr><code>getPortAnnotationsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortAnnotationsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port annotations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportannotations><code>getPortAnnotations</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortAnnotations</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port annotations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getannotationsattrforport><code>getAnnotationsAttrForPort</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getAnnotationsAttrForPort</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s annotations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getannotationsforport><code>getAnnotationsForPort</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getAnnotationsForPort</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s annotations
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportsymbolsattr><code>getPortSymbolsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortSymbolsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port symbols attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportsymbols><code>getPortSymbols</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortSymbols</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port symbols
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=hasportsymbolattr><code>hasPortSymbolAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>hasPortSymbolAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Check if port has symbol attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbols><code>setPortSymbols</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbols</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>symbols</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the symbols of all ports and their fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbolattr><code>setPortSymbolAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbolAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>,</span> <span class=n>StringAttr</span> <span class=n>symbol</span><span class=p>);</span>
</span></span></code></pre></div><p>Set a port&rsquo;s top-level symbol to the specified string, dropping any symbols on its fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbolsattr><code>setPortSymbolsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbolsAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>,</span> <span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerSymAttr</span> <span class=n>symbol</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the symbols for a port including its fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbol><code>setPortSymbol</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbol</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>,</span> <span class=n>StringRef</span> <span class=n>symbol</span><span class=p>);</span>
</span></span></code></pre></div><p>Set a port&rsquo;s top-level symbol to the specified string, dropping any symbols on its fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocationsattr><code>getPortLocationsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortLocationsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port locations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocations><code>getPortLocations</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortLocations</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port locations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocationattr><code>getPortLocationAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LocationAttr</span> <span class=nf>getPortLocationAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s location attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocation><code>getPortLocation</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Location</span> <span class=nf>getPortLocation</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s location
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getports><code>getPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>PortInfo</span><span class=o>&gt;</span> <span class=n>getPorts</span><span class=p>();</span>
</span></span></code></pre></div><p>Get information about all ports
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=insertports><code>insertPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>insertPorts</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=p>,</span> <span class=n>PortInfo</span><span class=o>&gt;&gt;</span> <span class=n>ports</span><span class=p>);</span>
</span></span></code></pre></div><p>Inserts the given ports at the corresponding indices
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=eraseports><code>erasePorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>erasePorts</span><span class=p>(</span><span class=k>const</span> <span class=n>llvm</span><span class=o>::</span><span class=n>BitVector</span><span class=o>&amp;</span><span class=n>portIndices</span><span class=p>);</span>
</span></span></code></pre></div><p>Erases the ports that have their corresponding bit set in <code>portIndices</code>
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=fnamableop-fnamableop>FNamableOp (<code>FNamableOp</code>)</h2><p>The interface provides common methods for namable operations
related to name preservation semantics.</p><h3 id=methods-2>Methods:</h3><h4 id=hasdroppablename><code>hasDroppableName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>hasDroppableName</span><span class=p>();</span>
</span></span></code></pre></div><p>Return true if the name is droppable.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=dropname><code>dropName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>dropName</span><span class=p>();</span>
</span></span></code></pre></div><p>Make the name droppable.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setnamekindattr><code>setNameKindAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setNameKindAttr</span><span class=p>(</span><span class=n>firrtl</span><span class=o>::</span><span class=n>NameKindEnumAttr</span> <span class=n>nameKind</span><span class=p>);</span>
</span></span></code></pre></div><p>Set a namekind.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getnameattr><code>getNameAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>StringAttr</span> <span class=n>getNameAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Return the name.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getname><code>getName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span> <span class=n>getName</span><span class=p>();</span>
</span></span></code></pre></div><p>Return the name.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=forceable-forceable>Forceable (<code>Forceable</code>)</h2><p>Interaction with declarations of forceable hardware components,
and managing references to them.</p><h3 id=methods-3>Methods:</h3><h4 id=isforceable><code>isForceable</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isForceable</span><span class=p>();</span>
</span></span></code></pre></div><p>Return true if the operation is forceable.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdata><code>getData</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>TypedValue</span><span class=o>&lt;</span><span class=n>FIRRTLBaseType</span><span class=o>&gt;</span> <span class=n>getData</span><span class=p>();</span>
</span></span></code></pre></div><p>Return data value that will be targeted.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdataraw><code>getDataRaw</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Value</span> <span class=nf>getDataRaw</span><span class=p>();</span>
</span></span></code></pre></div><p>Return raw data value that will be targeted.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdatatype><code>getDataType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>FIRRTLBaseType</span> <span class=nf>getDataType</span><span class=p>();</span>
</span></span></code></pre></div><p>Return data type that will be referenced.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdataref><code>getDataRef</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>TypedValue</span><span class=o>&lt;</span><span class=n>RefType</span><span class=o>&gt;</span> <span class=n>getDataRef</span><span class=p>();</span>
</span></span></code></pre></div><p>Return reference result, or null if not active.
NOTE: This method <em>must</em> be implemented by the user.</p><h2>'firrtl' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/ title="The Elastic Silicon Interconnect dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - The Elastic Silicon Interconnect dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/ title="FIRRTL Annotations">Next - FIRRTL Annotations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/DCPasses/></a></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>