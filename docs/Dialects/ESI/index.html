<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'esi' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/ESI/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'esi' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#esidecodecapnp-circtesicapnpdecodeop><code>esi.decode.capnp</code> (::circt::esi::CapnpDecodeOp)</a></li><li><a href=#esiencodecapnp-circtesicapnpencodeop><code>esi.encode.capnp</code> (::circt::esi::CapnpEncodeOp)</a></li><li><a href=#esibuffer-circtesichannelbufferop><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</a></li><li><a href=#esicosim-circtesicosimendpointop><code>esi.cosim</code> (::circt::esi::CosimEndpointOp)</a></li><li><a href=#esiservicedecl-circtesicustomservicedeclop><code>esi.service.decl</code> (::circt::esi::CustomServiceDeclOp)</a></li><li><a href=#esipure_moduleinput-circtesiesipuremoduleinputop><code>esi.pure_module.input</code> (::circt::esi::ESIPureModuleInputOp)</a></li><li><a href=#esipure_module-circtesiesipuremoduleop><code>esi.pure_module</code> (::circt::esi::ESIPureModuleOp)</a></li><li><a href=#esipure_moduleoutput-circtesiesipuremoduleoutputop><code>esi.pure_module.output</code> (::circt::esi::ESIPureModuleOutputOp)</a></li><li><a href=#esipure_moduleparam-circtesiesipuremoduleparamop><code>esi.pure_module.param</code> (::circt::esi::ESIPureModuleParamOp)</a></li><li><a href=#esinull-circtesinullsourceop><code>esi.null</code> (::circt::esi::NullSourceOp)</a></li><li><a href=#esistage-circtesipipelinestageop><code>esi.stage</code> (::circt::esi::PipelineStageOp)</a></li><li><a href=#esimemram-circtesirandomaccessmemorydeclop><code>esi.mem.ram</code> (::circt::esi::RandomAccessMemoryDeclOp)</a></li><li><a href=#esiservicereqinout-circtesirequestinoutchannelop><code>esi.service.req.inout</code> (::circt::esi::RequestInOutChannelOp)</a></li><li><a href=#esiservicereqto_client-circtesirequesttoclientconnectionop><code>esi.service.req.to_client</code> (::circt::esi::RequestToClientConnectionOp)</a></li><li><a href=#esiservicereqto_server-circtesirequesttoserverconnectionop><code>esi.service.req.to_server</code> (::circt::esi::RequestToServerConnectionOp)</a></li><li><a href=#esiserviceinout-circtesiservicedeclinoutop><code>esi.service.inout</code> (::circt::esi::ServiceDeclInOutOp)</a></li><li><a href=#esiservicehierarchymetadata-circtesiservicehierarchymetadataop><code>esi.service.hierarchy.metadata</code> (::circt::esi::ServiceHierarchyMetadataOp)</a></li><li><a href=#esiserviceimpl_req-circtesiserviceimplementreqop><code>esi.service.impl_req</code> (::circt::esi::ServiceImplementReqOp)</a></li><li><a href=#esiserviceinstance-circtesiserviceinstanceop><code>esi.service.instance</code> (::circt::esi::ServiceInstanceOp)</a></li><li><a href=#esiserviceto_client-circtesitoclientop><code>esi.service.to_client</code> (::circt::esi::ToClientOp)</a></li><li><a href=#esiserviceto_server-circtesitoserverop><code>esi.service.to_server</code> (::circt::esi::ToServerOp)</a></li><li><a href=#esiunwrapfifo-circtesiunwrapfifoop><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</a></li><li><a href=#esiunwrapiface-circtesiunwrapsvinterfaceop><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</a></li><li><a href=#esiunwrapvr-circtesiunwrapvalidreadyop><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</a></li><li><a href=#esiwindowunwrap-circtesiunwrapwindow><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</a></li><li><a href=#esiwrapfifo-circtesiwrapfifoop><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</a></li><li><a href=#esiwrapiface-circtesiwrapsvinterfaceop><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</a></li><li><a href=#esiwrapvr-circtesiwrapvalidreadyop><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</a></li><li><a href=#esiwindowwrap-circtesiwrapwindow><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#channeltype>ChannelType</a></li><li><a href=#anytype>AnyType</a></li><li><a href=#listtype>ListType</a></li><li><a href=#windowtype>WindowType</a></li><li><a href=#windowfieldtype>WindowFieldType</a></li><li><a href=#windowframetype>WindowFrameType</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=esidecodecapnp-circtesicapnpdecodeop><code>esi.decode.capnp</code> (::circt::esi::CapnpDecodeOp)</h3><p>Translate bits in Cap&rsquo;nProto messages to HW typed data</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.decode.capnp` $clk $valid $capnpBits attr-dict `:` qualified(type($capnpBits)) `-&gt;`
              qualified(type($decodedData))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>capnpBits</code></td><td>an HW bit array</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>decodedData</code></td><td>any type</td></tr></tbody></table><h3 id=esiencodecapnp-circtesicapnpencodeop><code>esi.encode.capnp</code> (::circt::esi::CapnpEncodeOp)</h3><p>Translate HW typed data to Cap&rsquo;nProto</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.encode.capnp` $clk $valid $dataToEncode attr-dict `:` qualified(type($dataToEncode))
              `-&gt;` qualified(type($capnpBits))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>dataToEncode</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>capnpBits</code></td><td>an HW bit array</td></tr></tbody></table><h3 id=esibuffer-circtesichannelbufferop><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</h3><p>Control options for an ESI channel.</p><p>A channel buffer (<code>buffer</code>) is essentially a set of options on a channel.
It always adds at least one cycle of latency (pipeline stage) to the
channel, but this is configurable.</p><p>This operation is inserted on an ESI dataflow edge. It must exist
previous to SystemVerilog emission but can be added in a lowering pass.</p><p>A <code>stages</code> attribute may be provided to specify a specific number of cycles
(pipeline stages) to use on this channel. Must be greater than 0.</p><p>A <code>name</code> attribute may be provided to assigned a name to a buffered
connection.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%esiChan</span> <span class=p>=</span> hw<span class=p>.</span>instance <span class=s>&#34;sender&#34;</span> <span class=nf>@Sender</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=c>// Allow automatic selection of options.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%bufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>instance <span class=s>&#34;recv&#34;</span> <span class=nf>@Reciever</span> <span class=p>(</span><span class=nv>%bufferedChan</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Alternatively, specify the number of stages.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%fourStageBufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>{</span> <span class=nl>stages =</span> <span class=m>4</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ChannelOpInterface, ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>stages</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esicosim-circtesicosimendpointop><code>esi.cosim</code> (::circt::esi::CosimEndpointOp)</h3><p>Co-simulation endpoint</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim` $clk `,` $rst `,` $send `,` $name attr-dict
              `:` qualified(type($send)) `-&gt;` qualified(type($recv))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>ESI uses a serialization protocol called Cap&rsquo;n Proto (capnp for short).
The advantage of capnp is the decoding overhead: for value types (ints,
structs, etc.) there is none! This stands in contrast to Protocol Buffers
and Bond as their messages contain metadata for each field which must be
interpreted.</p><p>The advantage of using a well-supported serialization protocol is
language support &ndash; driver applications can be written in any language
supported by the specific protocol.</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>send</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>recv</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esiservicedecl-circtesicustomservicedeclop><code>esi.service.decl</code> (::circt::esi::CustomServiceDeclOp)</h3><p>An ESI service interface declaration</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.decl` $sym_name $ports attr-dict
</code></pre><p>A declaration of an ESI service interface. Defines a contract between a
service provider and its clients.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>esi<span class=p>.</span>service<span class=p>.</span>decl <span class=nf>@HostComms</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  esi<span class=p>.</span>service<span class=p>.</span>to_server send <span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;!</span>esi<span class=p>.</span>any<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  esi<span class=p>.</span>service<span class=p>.</span>to_client recieve <span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: HasParent&lt;::mlir::ModuleOp>, NoTerminator, SingleBlock</p><p>Interfaces: ServiceDeclOpInterface, Symbol</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=esipure_moduleinput-circtesiesipuremoduleinputop><code>esi.pure_module.input</code> (::circt::esi::ESIPureModuleInputOp)</h3><p>Inputs become input ports when the module is lowered</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module.input` $name attr-dict `:` type($value)
</code></pre><p>To create input ports when lowering a pure module op into an HWModuleOp, use
this op. This op is typically created by a service implementation generator.</p><p>If two &lsquo;input&rsquo; ops exist in the same block, the names match, and the type
matches they&rsquo;ll become one port during lowering. Two or more may not exist
with the same name and different types. Useful for &lsquo;clk&rsquo; and &lsquo;rst&rsquo;.</p><p>Traits: HasParent<esipuremoduleop></p><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=esipure_module-circtesiesipuremoduleop><code>esi.pure_module</code> (::circt::esi::ESIPureModuleOp)</h3><p>ESI pure module</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module` $sym_name attr-dict-with-keyword $body
</code></pre><p>A module containing only ESI channels and modules with only ESI ports. All
non-local connectivity is done through ESI services. If this module is the
top level in the design, then the design&rsquo;s actual top level ports are
defined by a BSP.</p><p>Useful on its own for simulation and BSPs which don&rsquo;t define a top-level.</p><p>Traits: HasParent
<a href=mlir::ModuleOp>mlir::ModuleOp</a>, NoRegionArguments, NoTerminator, SingleBlock</p><p>Interfaces: HWModuleLike, RegionKindInterface, Symbol</p><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=esipure_moduleoutput-circtesiesipuremoduleoutputop><code>esi.pure_module.output</code> (::circt::esi::ESIPureModuleOutputOp)</h3><p>Outputs become output ports when the module is lowered</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module.output` $name `,` $value attr-dict `:` type($value)
</code></pre><p>To create output ports when lowering a pure module op into an HWModuleOp, use
this op. This op is typically created by a service implementation generator.</p><p>Two &lsquo;output&rsquo; ops with the same name cannot exist in the same block.</p><p>Traits: HasParent<esipuremoduleop></p><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=esipure_moduleparam-circtesiesipuremoduleparamop><code>esi.pure_module.param</code> (::circt::esi::ESIPureModuleParamOp)</h3><p>Params become module parameters when the module is lowered</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module.param` $name `:` $type attr-dict
</code></pre><p>Allows attaching parameters to modules which become HW module parameters
when lowering. Currently, they are ignored. Some low-level BSPs instantiate
modules with parameters. This allows the modules produced to accept
parameters so those BSPs can instantiate them.</p><p>Traits: HasParent<esipuremoduleop></p><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>type</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h3 id=esinull-circtesinullsourceop><code>esi.null</code> (::circt::esi::NullSourceOp)</h3><p>An op which never produces messages.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.null` attr-dict `:` qualified(type($out))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esistage-circtesipipelinestageop><code>esi.stage</code> (::circt::esi::PipelineStageOp)</h3><p>An elastic buffer stage.</p><p>An individual elastic pipeline register. Generally lowered to from a
ChannelBuffer (&lsquo;buffer&rsquo;), though can be inserted anywhere to add an
additional pipeline stage. Adding individually could be useful for
late-pass latency balancing.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ChannelOpInterface, ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esimemram-circtesirandomaccessmemorydeclop><code>esi.mem.ram</code> (::circt::esi::RandomAccessMemoryDeclOp)</h3><p>Random access memory service</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.mem.ram` $sym_name $innerType `x` $depth attr-dict
</code></pre><p>Declares a service which is backed by a memory of some sort. Allows random
access of the inner elements.</p><p>Ports:
read(address: clog2(depth)) -> data: innerType
write({address: clog2(depth), data: innerType}) -> done: i0</p><p>Users can ensure R/W ordering by waiting for the write &ldquo;done&rdquo; message before
issuing a potentially dependant read. Ordering of R/W messages in flight is
undefined.</p><p>Traits: HasParent&lt;::mlir::ModuleOp>, NoTerminator, SingleBlock</p><p>Interfaces: ServiceDeclOpInterface, Symbol</p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>innerType</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td style=text-align:center><code>depth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=esiservicereqinout-circtesirequestinoutchannelop><code>esi.service.req.inout</code> (::circt::esi::RequestInOutChannelOp)</h3><p>Request a bidirectional channel</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.req.inout` $toServer `-&gt;` $servicePort `(` $clientNamePath `)` attr-dict `:`
              qualified(type($toServer)) `-&gt;` qualified(type($toClient))
</code></pre><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>servicePort</code></td><td style=text-align:center>::circt::hw::InnerRefAttr</td><td>name reference attribute</td></tr><tr><td style=text-align:center><code>clientNamePath</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toServer</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toClient</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esiservicereqto_client-circtesirequesttoclientconnectionop><code>esi.service.req.to_client</code> (::circt::esi::RequestToClientConnectionOp)</h3><p>Request a connection to receive data</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.req.to_client` $servicePort `(` $clientNamePath `)`
              attr-dict `:` qualified(type($toClient))
</code></pre><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>servicePort</code></td><td style=text-align:center>::circt::hw::InnerRefAttr</td><td>name reference attribute</td></tr><tr><td style=text-align:center><code>clientNamePath</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toClient</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esiservicereqto_server-circtesirequesttoserverconnectionop><code>esi.service.req.to_server</code> (::circt::esi::RequestToServerConnectionOp)</h3><p>Request a connection to send data</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.req.to_server` $toServer `-&gt;` $servicePort `(` $clientNamePath `)`
              attr-dict `:` qualified(type($toServer))
</code></pre><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>servicePort</code></td><td style=text-align:center>::circt::hw::InnerRefAttr</td><td>name reference attribute</td></tr><tr><td style=text-align:center><code>clientNamePath</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toServer</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esiserviceinout-circtesiservicedeclinoutop><code>esi.service.inout</code> (::circt::esi::ServiceDeclInOutOp)</h3><p>An ESI service port which has both directions</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.inout` $inner_sym attr-dict
              `:` qualified($toServerType) `-&gt;` qualified($toClientType)
</code></pre><p>Traits: HasParent&lt;::circt::esi::CustomServiceDeclOp></p><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>toServerType</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td style=text-align:center><code>toClientType</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h3 id=esiservicehierarchymetadata-circtesiservicehierarchymetadataop><code>esi.service.hierarchy.metadata</code> (::circt::esi::ServiceHierarchyMetadataOp)</h3><p>Metadata about a service in the service hierarchy</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.hierarchy.metadata` `path` $serverNamePath (`implementing` $service_symbol^)?
              `impl` `as` $impl_type (`opts` $impl_details^)?
              `clients` $clients attr-dict
</code></pre><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>service_symbol</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>serverNamePath</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td style=text-align:center><code>impl_type</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>impl_details</code></td><td style=text-align:center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr><tr><td style=text-align:center><code>clients</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h3 id=esiserviceimpl_req-circtesiserviceimplementreqop><code>esi.service.impl_req</code> (::circt::esi::ServiceImplementReqOp)</h3><p>Request for a service to be implemented</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.impl_req` (`svc` $service_symbol^)? `impl` `as` $impl_type (`opts` $impl_opts^)?
              `(` $inputs `)` attr-dict `:` functional-type($inputs, results)
              $portReqs
</code></pre><p>The connect services pass replaces <code>service.instance</code>s with this op. The
<code>portReqs</code> region is the set of connection requests which need to be
implemented for this service instance. Channels to/from the requests have
been added to the operands/results of this op and consumers/producers have
been redirected.</p><p>Some other pass or frontend is expected to replace this op with an actual
implementation.</p><p>Traits: NoTerminator</p><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>service_symbol</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>impl_type</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>impl_opts</code></td><td style=text-align:center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></tbody></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>any type</td></tr></tbody></table><h3 id=esiserviceinstance-circtesiserviceinstanceop><code>esi.service.instance</code> (::circt::esi::ServiceInstanceOp)</h3><p>Instantiate a server module</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.instance` (`svc` $service_symbol^)? `impl` `as` $impl_type (`opts` $impl_opts^)?
              `(` $inputs `)` attr-dict `:` functional-type($inputs, results)
</code></pre><p>Instantiate a service adhering to a service declaration interface.</p><p>A pass collects all of the connection requests to the service this op
implements from the containing modules&rsquo; descendants (in the instance
hierarchy). It bubbles them all up to the module containing this op,
creating the necessary ESI channel ports, groups them appropriately, then
replaces this op with a <code>service.impl_req</code>.</p><p>If &lsquo;service_symbol&rsquo; isn&rsquo;t specified, this instance will be used to implement
all of the service requests which get surfaced to here. This option is
generally used at the top level to specify host connectivity.</p><p>Since implementing the server will usually need &ldquo;normal&rdquo; I/O, <code>inputs</code> and
<code>results</code> act like normal <code>hw.instance</code> ports.</p><p>$identifier is used by frontends to specify or remember the type of
implementation to use for this service.</p><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>service_symbol</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>impl_type</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>impl_opts</code></td><td style=text-align:center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></tbody></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=esiserviceto_client-circtesitoclientop><code>esi.service.to_client</code> (::circt::esi::ToClientOp)</h3><p>An ESI service port headed to a particular client</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.to_client` $inner_sym  attr-dict `:` $toClientType
</code></pre><p>Traits: HasParent&lt;::circt::esi::CustomServiceDeclOp></p><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>toClientType</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h3 id=esiserviceto_server-circtesitoserverop><code>esi.service.to_server</code> (::circt::esi::ToServerOp)</h3><p>An ESI service port headed to the service</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.to_server` $inner_sym attr-dict `:` $toServerType
</code></pre><p>Traits: HasParent&lt;::circt::esi::CustomServiceDeclOp></p><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>toServerType</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h3 id=esiunwrapfifo-circtesiunwrapfifoop><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</h3><p>Unwrap a value from an ESI port into a FIFO interface</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))
</code></pre><p>Interfaces: ChannelOpInterface, InferTypeOpInterface</p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>An ESI-compatible channel port</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiunwrapiface-circtesiunwrapsvinterfaceop><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</h3><p>Unwrap an SV interface from an ESI port</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`
</code></pre><p>Unwrap an ESI channel into a SystemVerilog interface containing valid,
ready, and data signals.</p><p>Interfaces: ChannelOpInterface</p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>An ESI-compatible channel port</td></tr><tr><td style=text-align:center><code>interfaceSource</code></td><td>sv.interface</td></tr></tbody></table><h3 id=esiunwrapvr-circtesiunwrapvalidreadyop><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</h3><p>Unwrap a value from an ESI port</p><p>Unwrapping a value allows operations on the contained value. Unwrap the
channel along with a ready signal that you generate. Result is the data
along with a valid signal.</p><p>Interfaces: ChannelOpInterface</p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>An ESI-compatible channel port</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawOutput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowunwrap-circtesiunwrapwindow><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</h3><p>unwrap a data window into a union</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h3 id=esiwrapfifo-circtesiwrapfifoop><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</h3><p>Wrap a value into an ESI port with FIFO signaling</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`
              custom&lt;WrapFIFOType&gt;(type($data), type($chanOutput))
</code></pre><p>Interfaces: ChannelOpInterface</p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>An ESI-compatible channel port</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwrapiface-circtesiwrapsvinterfaceop><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</h3><p>Wrap an SV interface into an ESI port</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `-&gt;` qualified(type($output))
</code></pre><p>Wrap a SystemVerilog interface into an ESI channel. Interface MUST look
like an interface produced by ESI meaning it MUST contain valid, ready,
and data signals. Any other signals will be discarded.</p><p>Interfaces: ChannelOpInterface</p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>interfaceSink</code></td><td>sv.interface</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An ESI-compatible channel port</td></tr></tbody></table><h3 id=esiwrapvr-circtesiwrapvalidreadyop><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</h3><p>Wrap a value into an ESI port</p><p>Wrapping a value into an ESI port type allows modules to send values down
an ESI port. Wrap data with valid bit, result is the ESI channel and the
ready signal from the other end of the channel.</p><p>Interfaces: ChannelOpInterface</p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawInput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>An ESI-compatible channel port</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowwrap-circtesiwrapwindow><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</h3><p>wrap a union into a data window</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.wrap` $frame attr-dict `:` custom&lt;InferWindowRet&gt;(type($frame), type($window))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h2 id=type-definition>Type definition</h2><h3 id=channeltype>ChannelType</h3><p>An ESI-compatible channel port</p><p>Syntax:</p><pre tabindex=0><code>!esi.channel&lt;
  Type,   # inner
  ::circt::esi::ChannelSignaling   # signaling
&gt;
</code></pre><p>An ESI port kind which models a latency-insensitive, unidirectional,
point-to-point data stream. Channels are typed (like all of ESI). Said
type can be any MLIR type, but must be lowered to something a backend
knows how to output (i.e. something emitVerilog knows about).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module<span class=p>.</span>extern <span class=nf>@Sender</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%x</span><span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@Reciever</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>5x</span><span class=k>i16</span><span class=p>&gt;&gt;)</span> <span class=p>{</span> <span class=p>}</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inner</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>signaling</td><td style=text-align:center><code>::circt::esi::ChannelSignaling</code></td><td></td></tr></tbody></table><h3 id=anytype>AnyType</h3><p>any type</p><p>Syntax: <code>!esi.any</code></p><p>Used to state that any type is accepted. The specific type will be
determined later in compilation.</p><h3 id=listtype>ListType</h3><p>a runtime-variably sized list</p><p>Syntax:</p><pre tabindex=0><code>!esi.list&lt;
  Type   # elementType
&gt;
</code></pre><p>In software, a chunk of memory with runtime-specified length. In hardware, a
stream of runtime-specified amount of data transmitted over many cycles in
compile-time specified specified windows (chunks).</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=windowtype>WindowType</h3><p>a data window</p><p>Syntax:</p><pre tabindex=0><code>!esi.window&lt;
  StringAttr,   # name
  mlir::Type,   # into
  ::llvm::ArrayRef&lt;WindowFrameType&gt;   # frames
&gt;
</code></pre><p>A &lsquo;data window&rsquo; allows designers to break up large messages into multiple
frames (aka phits) spread across multiple cycles. Windows are specified in
terms of a mapping of struct fields to frames. The width of a window is the
maximum frame size + the union tag (log2(#frames)).</p><p>A data window does NOT imply an ESI channel.</p><p>Current restrictions:</p><ul><li>A field may only appear once.</li><li>Fields may only be re-ordered (wrt the original message) within a frame.</li><li>Array fields whose array length is not evenly divisible by &rsquo;numItems&rsquo; will
have an implicit frame inserted directly after containing the leftover array
items.</li><li>Array fields with an array length MUST be in their own frame.</li></ul><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>into</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>frames</td><td style=text-align:center><code>::llvm::ArrayRef&lt;WindowFrameType></code></td><td></td></tr></tbody></table><h3 id=windowfieldtype>WindowFieldType</h3><p>a field-in-frame specifier</p><p>Syntax:</p><pre tabindex=0><code>!esi.window.field&lt;
  StringAttr,   # fieldName
  uint64_t   # numItems
&gt;
</code></pre><p>Specify that a field should appear within the enclosing frame.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>fieldName</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>numItems</td><td style=text-align:center><code>uint64_t</code></td><td># of items in arrays or lists</td></tr></tbody></table><h3 id=windowframetype>WindowFrameType</h3><p>Declare a data window frame</p><p>Syntax:</p><pre tabindex=0><code>!esi.window.frame&lt;
  StringAttr,   # name
  ::llvm::ArrayRef&lt;WindowFieldType&gt;   # members
&gt;
</code></pre><p>A named list of fields which should appear in a given frame.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>members</td><td style=text-align:center><code>::llvm::ArrayRef&lt;WindowFieldType></code></td><td></td></tr></tbody></table><h2>'esi' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/ title="DC Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - DC Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/ESI/cosim/ title="ESI cosimulation model">Next - ESI cosimulation model <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/DCPasses/></a></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>