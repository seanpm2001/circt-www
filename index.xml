<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CIRCT</title><link>https://circt.llvm.org/</link><description>Recent content on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/DCPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/DCPasses/</guid><description>-dc-dematerialize-forks-sinks: Dematerialize fork and sink operations. This pass analyses a function-like operation and removes all fork and sink operations.
-dc-materialize-forks-sinks: Materialize fork and sink operations. This pass analyses a function-like operation and inserts fork and sink operations ensuring that all values have exactly one use.</description></item><item><title>'arc' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Arc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Arc/</guid><description>Canonical representation of state transfer in a circuit This is the arc dialect, useful for representing state transfer functions in a circuit.
Operation definition arc.alloc_memory (circt::arc::AllocMemoryOp) arc.alloc_state (circt::arc::AllocStateOp) arc.alloc_storage (circt::arc::AllocStorageOp) arc.call (circt::arc::CallOp) arc.clock_domain (circt::arc::ClockDomainOp) arc.clock_gate (circt::arc::ClockGateOp) arc.clock_tree (circt::arc::ClockTreeOp) arc.define (circt::arc::DefineOp) arc.lut (circt::arc::LutOp) arc.memory (circt::arc::MemoryOp) arc.memory_read (circt::arc::MemoryReadOp) arc.memory_read_port (circt::arc::MemoryReadPortOp) arc.memory_write (circt::arc::MemoryWriteOp) arc.memory_write_port (circt::arc::MemoryWritePortOp) arc.model (circt::arc::ModelOp) arc.output (circt::arc::OutputOp) arc.passthrough (circt::arc::PassThroughOp) arc.root_input (circt::arc::RootInputOp) arc.root_output (circt::arc::RootOutputOp) arc.state (circt::arc::StateOp) arc.state_read (circt::arc::StateReadOp) arc.state_write (circt::arc::StateWriteOp) arc.storage.get (circt::arc::StorageGetOp) arc.</description></item><item><title>'calyx' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Calyx/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Calyx/</guid><description>Types and operations for the Calyx dialect Calyx is an intermediate language and infrastructure for building compilers that generate custom hardware accelerators. For more information, visit the documentation.
Operation definition calyx.std_add (::circt::calyx::AddLibOp) calyx.std_and (::circt::calyx::AndLibOp) calyx.assign (::circt::calyx::AssignOp) calyx.comb_component (::circt::calyx::CombComponentOp) calyx.comb_group (::circt::calyx::CombGroupOp) calyx.component (::circt::calyx::ComponentOp) calyx.control (::circt::calyx::ControlOp) calyx.std_divs_pipe (::circt::calyx::DivSPipeLibOp) calyx.std_divu_pipe (::circt::calyx::DivUPipeLibOp) calyx.enable (::circt::calyx::EnableOp) calyx.std_eq (::circt::calyx::EqLibOp) calyx.std_extsi (::circt::calyx::ExtSILibOp) calyx.std_ge (::circt::calyx::GeLibOp) calyx.group_done (::circt::calyx::GroupDoneOp) calyx.group_go (::circt::calyx::GroupGoOp) calyx.group (::circt::calyx::GroupOp) calyx.std_gt (::circt::calyx::GtLibOp) calyx.if (::circt::calyx::IfOp) calyx.instance (::circt::calyx::InstanceOp) calyx.std_le (::circt::calyx::LeLibOp) calyx.</description></item><item><title>'chirrtl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/CHIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/CHIRRTL/</guid><description>Types and operations for the chirrtl dialect This dialect defines the chirrtl dialect, which contains high-level memory defintions which can be lowered to FIRRTL.
Operation definition chirrtl.combmem (::circt::chirrtl::CombMemOp) chirrtl.debugport (::circt::chirrtl::MemoryDebugPortOp) chirrtl.memoryport.access (::circt::chirrtl::MemoryPortAccessOp) chirrtl.memoryport (::circt::chirrtl::MemoryPortOp) chirrtl.seqmem (::circt::chirrtl::SeqMemOp) Type definition CMemoryPortType CMemoryType Operation definition chirrtl.combmem (::circt::chirrtl::CombMemOp) Define a new combinational memory
Syntax:
operation ::= `chirrtl.combmem` (`sym` $inner_sym^)? `` custom&amp;lt;NameKind&amp;gt;($nameKind) `` custom&amp;lt;CombMemOp&amp;gt;(attr-dict) `:` qualified(type($result)) Define a new behavioral combinational memory. Combinational memories have a write latency of 1 and a read latency of 0.</description></item><item><title>'llhd' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LLHD/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LLHD/</guid><description>A low-level hardware description dialect in MLIR.
Operation definition llhd.con (::circt::llhd::ConnectOp) llhd.constant_time (::circt::llhd::ConstantTimeOp) llhd.drv (::circt::llhd::DrvOp) llhd.entity (::circt::llhd::EntityOp) llhd.halt (::circt::llhd::HaltOp) llhd.inst (::circt::llhd::InstOp) llhd.load (::circt::llhd::LoadOp) llhd.output (::circt::llhd::OutputOp) llhd.prb (::circt::llhd::PrbOp) llhd.proc (::circt::llhd::ProcOp) llhd.ptr.array_get (::circt::llhd::PtrArrayGetOp) llhd.ptr.array_slice (::circt::llhd::PtrArraySliceOp) llhd.ptr.extract (::circt::llhd::PtrExtractOp) llhd.ptr.struct_extract (::circt::llhd::PtrStructExtractOp) llhd.reg (::circt::llhd::RegOp) llhd.sig.array_get (::circt::llhd::SigArrayGetOp) llhd.sig.array_slice (::circt::llhd::SigArraySliceOp) llhd.sig.extract (::circt::llhd::SigExtractOp) llhd.sig (::circt::llhd::SigOp) llhd.sig.struct_extract (::circt::llhd::SigStructExtractOp) llhd.store (::circt::llhd::StoreOp) llhd.var (::circt::llhd::VarOp) llhd.wait (::circt::llhd::WaitOp) Attribute definition TimeAttr Type constraint definition LLHD time type Type definition PtrType SigType TimeType Operation definition llhd.</description></item><item><title>'ltl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LTL/</guid><description>This dialect provides operations and types to model Linear Temporal Logic, sequences, and properties, which are useful for hardware verification.
Rationale Sequences and Properties Representing SVAs Sequence Concatenation and Cycle Delay Implication Clocking Disable Iff Representing the LTL Formalism Next / Delay Concatenation Types Overview PropertyType SequenceType Operations ltl.and (circt::ltl::AndOp) ltl.clock (circt::ltl::ClockOp) ltl.concat (circt::ltl::ConcatOp) ltl.delay (circt::ltl::DelayOp) ltl.disable (circt::ltl::DisableOp) ltl.eventually (circt::ltl::EventuallyOp) ltl.implication (circt::ltl::ImplicationOp) ltl.not (circt::ltl::NotOp) ltl.or (circt::ltl::OrOp) Rationale The main goal of the ltl dialect is to capture the core formalism underpinning SystemVerilog Assertions (SVAs), the de facto standard for describing temporal logic sequences and properties in hardware verification.</description></item><item><title>'moore' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Moore/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Moore/</guid><description>Types and operations for Moore dialect This dialect defines the moore dialect, which represents various SystemVerilog-specific constructs without ambiguities and all types resolved.
Operation definition moore.mir.assign (::circt::moore::AssignOp) moore.mir.concat (::circt::moore::ConcatOp) moore.mir.constant (::circt::moore::ConstantOp) moore.mir.shl (::circt::moore::ShlOp) moore.mir.shr (::circt::moore::ShrOp) moore.mir.vardecl (::circt::moore::VariableDeclOp) Type constraint definition an SystemVerilog int packed type simple bit vector type unpacked type Type definition LValueType Operation definition moore.mir.assign (::circt::moore::AssignOp) Continuous assignment
Syntax:
operation ::= `moore.mir.assign` $dest `,` $src attr-dict `:` qualified(type($src)) A SystemVerilog assignment statement &amp;lsquo;x = y;&amp;rsquo;.</description></item><item><title>'msft' Dialect</title><link>https://circt.llvm.org/docs/Dialects/MSFT/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/MSFT/</guid><description>Microsoft internal support dialect Umbrella dialect for everything needed to support Microsoft development but not thoroughly discussed. Most (if not everything) in this dialect is a candidate for generalization and re-homing.
Operation definition msft.constructs.channel (::circt::msft::ChannelOp) msft.physical_region (::circt::msft::DeclPhysicalRegionOp) msft.partition (::circt::msft::DesignPartitionOp) msft.instance.dynamic (::circt::msft::DynamicInstanceOp) msft.instance.verb_attr (::circt::msft::DynamicInstanceVerbatimAttrOp) msft.entity.extern (::circt::msft::EntityExternOp) msft.instance.hierarchy (::circt::msft::InstanceHierarchyOp) msft.instance (::circt::msft::InstanceOp) msft.hlc.linear (::circt::msft::LinearOp) msft.module.extern (::circt::msft::MSFTModuleExternOp) msft.module (::circt::msft::MSFTModuleOp) msft.output (::circt::msft::OutputOp) msft.pd.location (::circt::msft::PDPhysLocationOp) msft.pd.physregion (::circt::msft::PDPhysRegionOp) msft.pd.reg_location (::circt::msft::PDRegPhysLocationOp) msft.pe.output (::circt::msft::PEOutputOp) msft.systolic.array (::circt::msft::SystolicArrayOp) Attribute definition AppIDAttr LocationVectorAttr PhysLocationAttr PhysicalBoundsAttr Operation definition msft.</description></item><item><title>'pipeline' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Pipeline/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Pipeline/</guid><description>Operation definition pipeline.pipeline (::circt::pipeline::PipelineOp) pipeline.stage (::circt::pipeline::PipelineStageOp) pipeline.stage.register (::circt::pipeline::PipelineStageRegisterOp) pipeline.return (::circt::pipeline::ReturnOp) Operation definition pipeline.pipeline (::circt::pipeline::PipelineOp) pipeline operation
Syntax:
operation ::= `pipeline.pipeline` `(` $inputs `)` `clock` $clock `reset` $reset attr-dict `:` functional-type($inputs, results) $body The &amp;ldquo;pipeline.pipeline&amp;rdquo; operation represents a retimeable pipeline. The pipeline contains a single block representing a graph region. Pipeline stages are represented by pipeline.rt.register operations. Semantics of values crossing register boundaries are defined by lowering passes. The pipeline representation is centered around providing latency insensitive values (valid signals between stages).</description></item><item><title>'verif' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Verif/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Verif/</guid><description>This dialect provides a collection of operations to express various verification concerns, such as assertions and interacting with a piece of hardware for the sake of verifying its proper functioning.
Operations verif.assert (circt::verif::AssertOp) verif.assume (circt::verif::AssumeOp) verif.cover (circt::verif::CoverOp) Operations verif.assert (circt::verif::AssertOp) Assert that a property holds.
Syntax:
operation ::= `verif.assert` $property attr-dict `:` type($property) Operands: Operand Description property 1-bit signless integer or LTL sequence type or LTL property type verif.assume (circt::verif::AssumeOp) Assume that a property holds.</description></item><item><title>`comb` Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</guid><description>This document describes various design points of the Comb dialect, a common dialect that is typically used in conjunction with the hw and sv dialects. Please see the hw Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
comb Dialect Rationale Introduction to the comb Dialect Type System for comb Dialect Zero-bit integer width is not supported Comb Operations Fully associative operations are variadic Operators carry signs instead of types No implicit extensions of operands No &amp;ldquo;Complement&amp;rdquo;, &amp;ldquo;Negate&amp;rdquo;, &amp;ldquo;ZExt&amp;rdquo;, &amp;ldquo;SExt&amp;rdquo;, Operators No multibit mux operations Endianness: operand ordering and internal representation Bitcasts Cost Model Introduction to the comb Dialect The comb dialect provides a collection of operations that define a mid-level compiler IR for combinational logic.</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogeneous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>Compiling CIRCT and PyCDE</title><link>https://circt.llvm.org/docs/PyCDE/compiling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/compiling/</guid><description>PyCDE is compiled as a component of CIRCT which pulls in the LLVM/MLIR project as a submodule. As such, compiling it is complex and takes some time. If you&amp;rsquo;re not a CIRCT or PyCDE developer, use pip.
Cloning the repo If you havent already, you need to clone the CIRCT repo. Unless you already have contributor permissions to the LLVM project, the easiest way to develop (with the ability to create and push branches) is to fork the repo in your GitHub account.</description></item><item><title>DC Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/DC/RationaleDC/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/DC/RationaleDC/</guid><description>Introduction Canonicalization Introduction DC (Dynamic Control) IR describes independent, unsynchronized processes communicating data through First-in First-out (FIFO) communication channels. This can be implemented in many ways, such as using synchronous logic, or with processors.
The intention of DC is to model all operations required to represent such a control flow language. DC aims to be strictly a control flow dialect - as opposed to the Handshake dialect, which assigns control semantics to all SSA values.</description></item><item><title>EDA Tool Workarounds</title><link>https://circt.llvm.org/docs/ToolsWorkarounds/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/ToolsWorkarounds/</guid><description>This documents various bugs found in EDA tools and their workarounds in circt. Each but will have a brief description, example code, and the mitigation added (with links to the commit when possible).
Automatic Variables Cause Latch Warnings Verilator issues a latch warning for fully-initialized, automatic variables. This precludes using locally scoped variables. https://github.com/verilator/verilator/issues/4022
Example module ALU( input clock, input [4:0] operation, input [63:0] inputs_1, inputs_0, inputs_2, input [16:0] immediate, output [63:0] output_0 ); reg [63:0] casez_tmp_1; always_comb begin automatic logic [63:0] lowHigh; casez (operation) 5&amp;#39;b00011: casez_tmp_1 = inputs_0 &amp;amp; inputs_1; 5&amp;#39;b00100: casez_tmp_1 = inputs_0 | inputs_1; 5&amp;#39;b00101: casez_tmp_1 = inputs_0 ^ inputs_1; 5&amp;#39;b01001: begin automatic logic [16:0] _aluOutput_T_22 = immediate &amp;gt;&amp;gt; {14&amp;#39;h0, inputs_2, inputs_1[0], inputs_0[0]}; casez_tmp_1 = {63&amp;#39;h0, _aluOutput_T_22[0]}; end default: casez_tmp_1 = inputs_0; endcase end endmodule Gives:</description></item><item><title>ESI cosimulation model</title><link>https://circt.llvm.org/docs/Dialects/ESI/cosim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/cosim/</guid><description>Elastic Silicon Interfaces provides a feature called cosimulation. Cosim in general allows communication between the simulation and software. In the ESI case, it is typed and can be used to build an application and language specific API which is nearly identical to how the real hardware would interface. This allows users to simulate against the actual target software (or some simplification of it), enabling easier co-design.
ESI cosim uses Cap&amp;rsquo;nProto as a message format and RPC client/server.</description></item><item><title>ESI data types and communication types</title><link>https://circt.llvm.org/docs/Dialects/ESI/types/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/types/</guid><description>ESI has two different classes of MLIR types: ones which represent data on the wires (data types) and ones which specify the type of communication. From a user perspective, communication types aren&amp;rsquo;t really types &amp;ndash; this is just how the communication style is modeled in MLIR and thus an implementation detail.
Data types In addition to the types in the hw dialect, ESI will add few:
Void void translates to &amp;ldquo;no data&amp;rdquo;, meaning just a control signal.</description></item><item><title>ESI Global Services</title><link>https://circt.llvm.org/docs/Dialects/ESI/services/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/services/</guid><description>This section not fully fleshed out and suffers from poor writing.
ESI will provide access to global resource via ESI Services. These &amp;ldquo;buses&amp;rdquo; define a typed interface and instances are instantiated globally &amp;ndash; they should be accessible at all levels of the design hierarchy. ESI services are intended to provide access to truly global resources like PCIe, shared DMA engines, DRAM, network interfaces, etc. They are generic enough to be extended to non-physical interfaces like telemetry &amp;ndash; if you have a centralized telemetry reporting engine, you probably want any module or submodule in the design to be able to access and report to it.</description></item><item><title>ESI Software APIs</title><link>https://circt.llvm.org/docs/Dialects/ESI/software_api/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/software_api/</guid><description>More on this to be written.
Status: unimplemented
Thanks to ESI&amp;rsquo;s strong static typing, typed, design-dependent software APIs can be automatically generated. Said APIs would be mostly independent of the transport mechanism (PCIe, network, etc.) used to communicate with the silicon. The same API could even drive a simulation of the ESI system.
Said APIs would need to ensure that the software is talking to the correct hardware. There are several possible approaches:</description></item><item><title>FIRRTL Annotations</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/</guid><description>The Scala FIRRTL Compiler (SFC) provides a mechanism to encode arbitrary metadata and associate it with zero or more &amp;ldquo;things&amp;rdquo; in a FIRRTL circuit. This mechanism is an Annotation and the association is described using one or more Targets. Annotations should be viewed as an extension to the FIRRTL IR specification, and can greatly affect the meaning and interpretation of the IR.
Annotations are represented as a dictionary, with a &amp;ldquo;class&amp;rdquo; field which describes which annotation it is, and a &amp;ldquo;target&amp;rdquo; field which represents the IR object it is attached to.</description></item><item><title>FIRRTL Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/</guid><description>This document describes various design points of the FIRRTL dialect, why it is the way it is, and current status and progress. This follows in the spirit of other MLIR Rationale docs.
Introduction The FIRRTL project is an existing open source compiler infrastructure used by the Chisel framework to lower &amp;ldquo;.fir&amp;rdquo; files to Verilog. It provides a number of useful compiler passes and infrastructure that allows the development of domain specific passes.</description></item><item><title>FSM Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/</guid><description>This document describes various design points of the FSM dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Finite-state machine (FSM) is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>Handshake Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/</guid><description>Principle Choice of MLIR IR Representation Conventions Resources Operation definitions This document also explains in a high-level manner how different components are organized, the principles behind them and the conventions we followed. The document assume that you have basic understanding of asynchronous digital circuits at the behavioral level of abstraction.
Principle Handshake/dataflow IR describes independent, unsynchronized processes communicating data through First-in First-out (FIFO) communication channels. This can be implemented in many ways, such as using synchronous logic, or with processors.</description></item><item><title>handshake-runner</title><link>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</guid><description>SYNOPSIS | handshake-runner [options] [filename] [arguments]
DESCRIPTION This application executes a function in the given MLIR module. Arguments to the function are passed on the command line and results are returned on stdout. Memref types are specified as a comma-separated list of values. This particular tool is use to check the validity of Standard-to-Handshake conversion in CIRCT.
Example The following MLIR module first convert to Handshake IR with the circt-opt tool as circt-opt -create-dataflow &amp;lt;file-name&amp;gt;.</description></item><item><title>HW Arith Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/</guid><description>This document describes the various design points of the HWArith dialect, a dialect that is used to represent bitwidth extending arithmetic. This follows in the spirit of other MLIR Rationale docs.
HW Arith Dialect Rationale Introduction Q&amp;amp;A Bit Width Rules Lowering Introduction The hwarith dialect provides a collection of operations that define typical integer arithmetic operations which are bitwidth extending. These semantics are expressed through return type inference rules that, based on the types of an operation and its input operands, infers the type of the result operand.</description></item><item><title>HW Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/HW/RationaleHW/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/HW/RationaleHW/</guid><description>This document describes various design points of the hw dialect as well as global perspective on the hw, comb, and sv dialects, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs. For more information about the other dialects, please see the Comb Dialect Rationale and SV Dialect Rationale.
HW Dialect Rationale General Introduction Introduction to the hw Dialect hw Type System hw.</description></item><item><title>Interoperability Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/</guid><description>This document describes the various design points of the Interop dialect, a dialect that is used to represent partially lowered interoperability layers and that provides common interfaces and utilities for automated interop generation. This follows in the spirit of other MLIR Rationale docs.
Interoperability Dialect Rationale Introduction Procedural Interop Representing Partial Lowerings Interop Mechanisms Instance-side Lowering Container-side Lowering Bridging between Interop Mechanisms How to use this dialect Design considerations Introduction The increasing number of CIRCT-based backends as well as the usage of many external tools raises questions about interoperability and composition of those tools.</description></item><item><title>Intrinsics</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/</guid><description>Intrinsics provide an implementation-specific way to extend the FIRRTL language with new operations.
Intrinsics are currently implemented as annotated external modules. We expect that native FIRRTL support for intrinsics will be added to the language.
Motivation Intrinsics provide a way to add functionality to FIRRTL without having to extend the FIRRTL language. This allows a fast path for prototyping new operations to rapidly respond to output requirements. Intrinsics maintain strict definitions and type checking.</description></item><item><title>LoopSchedule Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/</guid><description>This document describes various design points of the loopschedule dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction The loopschedule dialect provides a collection of ops to represent software-like loops after scheduling. There are currently two main kinds of loops that can be represented: pipelined and sequential. Pipelined loops allow multiple iterations of the loop to be in-flight at a time and have an associated initiation interval (II) to specify the number of cycles between the start of successive loop iterations.</description></item><item><title>Miscellaneous Notes</title><link>https://circt.llvm.org/docs/Dialects/ESI/notes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/notes/</guid><description>ABI The ABI specifies how an ESI &amp;ldquo;API&amp;rdquo; is translated to hardware, specifically RTL. This involves both the wire-level signaling between modules and how data is arranged on those wires.
This section is purposely underspecified in this proposal as it should be an implementation detail which only advanced users need know. The main issues discussed here are how lists and data windows are lowered and presented to RTL modules. Lowering of fixed-size, default-presentation semantics ports is mostly straight forward, so is not discussed here.</description></item><item><title>Object Model Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/OM/RationaleOM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/OM/RationaleOM/</guid><description>This document describes various design points of the om dialect. This follows in the spirit of other MLIR Rationale docs.
Motivation The goal of the om dialect is to develop an IR suitable for domain modeling. It intends to accomplish this by providing constructs for capturing an Object Model (OM). Domain modeling in this context means capturing design intent and supporting tooling related to the creation of CPUs and SoCs. Anything other than RTL level design entry falls under this broad categorization, and must be intimately tied to RTL level design entry in a stable way.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -calyx-remove-groups-fsm: Perform FSM outlining and group removal -convert-affine-to-loopschedule: Convert Affine dialect to LoopSchedule scheduled loops -convert-comb-to-arith: Convert combinational ops and constants into arith ops -convert-fsm-to-sv: Convert FSM to HW -convert-hw-to-llhd: Convert HW to LLHD -convert-hw-to-llvm: Convert HW to LLVM -convert-hw-to-systemc: Convert HW to SystemC -convert-llhd-to-llvm: Convert LLHD to LLVM -convert-moore-to-core: Convert Moore to Core -convert-to-arcs: Outline logic between registers into state transfer arcs -export-chisel-interface: Emit a Chisel interface to a FIRRTL circuit -export-split-chisel-interface: Emit a Chisel interface to a FIRRTL circuit to a directory of files -export-split-verilog: Emit the IR to a (System)Verilog directory of files -export-verilog: Emit the IR to a (System)Verilog file -handshake-remove-block-structure: Remove block structure in Handshake IR -insert-merge-blocks: Insert explicit merge blocks -legalize-anon-enums: Prepare anonymous enumeration types for ExportVerilog -lower-arc-to-llvm: Lower state transfer arc representation to LLVM -lower-calyx-to-fsm: Lower Calyx to FSM -lower-calyx-to-hw: Lower Calyx to HW -lower-firrtl-to-hw: Lower FIRRTL to HW -lower-handshake-to-dc: Lower Handshake to DC -lower-handshake-to-hw: Lower Handshake to ESI/HW/Comb/Seq -lower-hwarith-to-hw: Lower HWArith to HW/Comb -lower-loopschedule-to-calyx: Lower LoopSchedule to Calyx -lower-pipeline-to-hw: Lower Pipeline to HW -lower-scf-to-calyx: Lower SCF/Standard to Calyx -lower-std-to-handshake: Lower Standard MLIR into Handshake IR -materialize-calyx-to-fsm: Materializes an FSM embedded inside the control of this Calyx component.</description></item><item><title>PyCDE Basics</title><link>https://circt.llvm.org/docs/PyCDE/basics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/basics/</guid><description>You know what&amp;rsquo;s more difficult than forcing yourself to write documentation? Maintaining it! We apologize for the inevitable inaccuracies.
Modules, Generators, and Systems from pycde import Input, Output, Module, System from pycde import generator from pycde.types import Bits class OrInts(Module): a = Input(Bits(32)) b = Input(Bits(32)) c = Output(Bits(32)) @generator def construct(self): self.c = self.a | self.b system = System([OrInts], name=&amp;#34;ExampleSystem&amp;#34;, output_directory=&amp;#34;exsys&amp;#34;) system.compile() Hardware modules extend pycde.Module. They define any number of typed inputs and outputs by setting class members.</description></item><item><title>Seq(uential) Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/</guid><description>This document describes various design points of the seq dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Digital logic is generally split into two categories: combinational and sequential. CIRCT contains a comb dialect to model the basic combinational operations and the (future) seq dialect which is discussed here. The intention of the seq dialect is to provide a set of stateful constructs which can be used to model sequential logic, independent of the output method (e.</description></item><item><title>SSP Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/</guid><description>This document describes various design points of the SSP dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction CIRCT&amp;rsquo;s scheduling infrastructure is lightweight and dialect-agnostic, in order to fit into any lowering flow with a need for static scheduling. However, it lacks an import/export format for storing and exchanging problem instances. The SSP (&amp;quot;Static Scheduling Problems&amp;quot;) dialect fills that role by defining an IR that captures problem instances</description></item><item><title>Static scheduling infrastructure</title><link>https://circt.llvm.org/docs/Scheduling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Scheduling/</guid><description>Scheduling is a common concern in hardware design, for example in high-level synthesis flows targeting an FSM+Datapath execution model (&amp;ldquo;static HLS&amp;rdquo;). This document gives an overview of, and provides rationale for, the infrastructure in the circt::scheduling namespace. At its core, it defines an extensible problem model that acts as an interface between clients (i.e. passes that have a need to schedule a graph-like IR) and reusable algorithm implementations.
This infrastructure aims to provide:</description></item><item><title>SV Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SV/RationaleSV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SV/RationaleSV/</guid><description>This document describes various design points of the sv dialect, a common dialect that is typically used in conjunction with the hw and comb dialects. Please see the HW Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
SV Dialect Rationale Introduction to the sv dialect sv Type System Overview of sv dialect operations Statements Declarations Expressions Verbatim op Cost Model SV Dialect Attributes Introduction to the sv dialect The sv dialect is one of the dialects that can be mixed into the HW dialect, providing access to a range of syntactic and behavioral constructs in SystemVerilog.</description></item><item><title>Symbol and Inner Symbol Rationale</title><link>https://circt.llvm.org/docs/RationaleSymbols/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSymbols/</guid><description>This document describes various design points of the major CIRCT dialects relating to the use of symbols and the introduction of inner symbols and related types. This follows in the spirit of other MLIR Rationale docs.
Introduction Verilog and FIRRTL have, from a software compiler perspective, an unusual number of nameable entities which can be referred to non-locally. These entities have deep nesting in the code structures. The requirements of dealing with these entities and references entails more complexity than provided by MLIR&amp;rsquo;s symbols and symbol tables.</description></item><item><title>SystemC Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/</guid><description>This document describes various design points of the SystemC dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
SystemC Dialect Rationale Introduction Lowering Q&amp;amp;A Introduction SystemC is a library written in C++ to allow functional modeling of systems. The included event-driven simulation kernel can then be used to simulate a system modeled entirely in SystemC. Additionally, SystemC is a standard (IEEE Std 1666-2011) supported by several tools (e.</description></item><item><title>The Elastic Silicon Interconnect dialect</title><link>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</guid><description>Long ago, software function calling conventions were ad-hoc. This led to issues, particularly with register clobbering and stack corruption. This is &amp;ndash; in large part &amp;ndash; the state of FPGA/ASIC design today: wire signaling protocols are often ad-hoc, which also leads to major issues. Though there are efforts to standardize the signaling protocols there are many minor and major variants, both of which lead to confusion which can cause real problems when one is listening to and twiddling the wires manually.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntactically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>